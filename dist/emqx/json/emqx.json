[
  {
    "fields": [
      {
        "name": "listeners",
        "type": {
          "kind": "struct",
          "name": "broker:listeners"
        }
      },
      {
        "desc": "A zone is a set of configs grouped by the zone <code>name</code>.\nFor flexible configuration mapping, the <code>name</code> can be set to a listener's <code>zone</code> config.\nNOTE: A built-in zone named <code>default</code> is auto created and can not be deleted.\n",
        "name": "zones",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "broker:zone"
          }
        }
      },
      {
        "desc": "Global MQTT configuration.\nThe configs here work as default values which can be overridden in <code>zone</code> configs\n",
        "name": "mqtt",
        "type": {
          "kind": "struct",
          "name": "broker:mqtt"
        }
      },
      {
        "desc": "Default authentication configs for all MQTT listeners.\n\nFor per-listener overrides see <code>authentication</code> in listener configs\n\nThis option can be configured with:\n<ul>\n  <li><code>[]</code>: The default value, it allows *ALL* logins</li>\n  <li>one: For example <code>{enable:true,backend:\"built_in_database\",mechanism=\"password_based\"}</code></li>\n  <li>chain: An array of structs.</li>\n</ul>\n\nWhen a chain is configured, the login credentials are checked against the backends per the configured order, until an 'allow' or 'deny' decision can be made.\n\nIf there is no decision after a full chain exhaustion, the login is rejected.\n",
        "name": "authentication",
        "type": {
          "elements": {
            "kind": "union",
            "members": [
              {
                "kind": "struct",
                "name": "authn-builtin_db:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-mysql:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-postgresql:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:standalone"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:replica-set"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:sharded-cluster"
              },
              {
                "kind": "struct",
                "name": "authn-redis:standalone"
              },
              {
                "kind": "struct",
                "name": "authn-redis:cluster"
              },
              {
                "kind": "struct",
                "name": "authn-redis:sentinel"
              },
              {
                "kind": "struct",
                "name": "authn-http:get"
              },
              {
                "kind": "struct",
                "name": "authn-http:post"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:hmac-based"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:public-key"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:jwks"
              },
              {
                "kind": "struct",
                "name": "authn-scram-builtin_db:authentication"
              }
            ]
          },
          "kind": "array"
        }
      },
      {
        "desc": "\nAuthorization a.k.a. ACL.<br/>\nIn EMQX, MQTT client access control is extremely flexible.<br/>\nAn out-of-the-box set of authorization data sources are supported.\nFor example,<br/>\n'file' source is to support concise and yet generic ACL rules in a file;<br/>\n'built_in_database' source can be used to store per-client customizable rule sets,\nnatively in the EMQX node;<br/>\n'http' source to make EMQX call an external HTTP API to make the decision;<br/>\n'PostgreSQL' etc. to look up clients or rules from external databases;<br/>\n",
        "name": "authorization",
        "type": {
          "kind": "struct",
          "name": "authorization"
        }
      },
      {
        "name": "node",
        "type": {
          "kind": "struct",
          "name": "node"
        }
      },
      {
        "name": "cluster",
        "type": {
          "kind": "struct",
          "name": "cluster"
        }
      },
      {
        "name": "log",
        "type": {
          "kind": "struct",
          "name": "log"
        }
      },
      {
        "name": "rpc",
        "type": {
          "kind": "struct",
          "name": "rpc"
        }
      },
      {
        "desc": "Message broker options.",
        "name": "broker",
        "type": {
          "kind": "struct",
          "name": "broker"
        }
      },
      {
        "desc": "System topics configuration.",
        "name": "sys_topics",
        "type": {
          "kind": "struct",
          "name": "broker:sys_topics"
        }
      },
      {
        "name": "force_shutdown",
        "type": {
          "kind": "struct",
          "name": "broker:force_shutdown"
        }
      },
      {
        "name": "overload_protection",
        "type": {
          "kind": "struct",
          "name": "broker:overload_protection"
        }
      },
      {
        "name": "force_gc",
        "type": {
          "kind": "struct",
          "name": "broker:force_gc"
        }
      },
      {
        "name": "conn_congestion",
        "type": {
          "kind": "struct",
          "name": "broker:conn_congestion"
        }
      },
      {
        "name": "stats",
        "type": {
          "kind": "struct",
          "name": "broker:stats"
        }
      },
      {
        "name": "sysmon",
        "type": {
          "kind": "struct",
          "name": "broker:sysmon"
        }
      },
      {
        "name": "alarm",
        "type": {
          "kind": "struct",
          "name": "broker:alarm"
        }
      },
      {
        "name": "flapping_detect",
        "type": {
          "kind": "struct",
          "name": "broker:flapping_detect"
        }
      },
      {
        "name": "persistent_session_store",
        "type": {
          "kind": "struct",
          "name": "broker:persistent_session_store"
        }
      },
      {
        "name": "trace",
        "type": {
          "kind": "struct",
          "name": "broker:trace"
        }
      },
      {
        "name": "bridges",
        "type": {
          "kind": "struct",
          "name": "bridge:bridges"
        }
      },
      {
        "name": "retainer",
        "type": {
          "kind": "struct",
          "name": "retainer"
        }
      },
      {
        "name": "statsd",
        "type": {
          "kind": "struct",
          "name": "statsd"
        }
      },
      {
        "name": "auto_subscribe",
        "type": {
          "kind": "struct",
          "name": "auto_subscribe"
        }
      },
      {
        "name": "delayed",
        "type": {
          "kind": "struct",
          "name": "modules:delayed"
        }
      },
      {
        "name": "telemetry",
        "type": {
          "kind": "struct",
          "name": "modules:telemetry"
        }
      },
      {
        "desc": "List of topic rewrite rules.",
        "name": "rewrite",
        "type": {
          "elements": {
            "kind": "struct",
            "name": "modules:rewrite"
          },
          "kind": "array"
        }
      },
      {
        "desc": "List of topics whose metrics are reported.",
        "name": "topic_metrics",
        "type": {
          "elements": {
            "kind": "struct",
            "name": "modules:topic_metrics"
          },
          "kind": "array"
        }
      },
      {
        "name": "plugins",
        "type": {
          "kind": "struct",
          "name": "plugin:plugins"
        }
      },
      {
        "name": "dashboard",
        "type": {
          "kind": "struct",
          "name": "dashboard"
        }
      },
      {
        "name": "gateway",
        "type": {
          "kind": "struct",
          "name": "gateway"
        }
      },
      {
        "name": "prometheus",
        "type": {
          "kind": "struct",
          "name": "prometheus"
        }
      },
      {
        "name": "rule_engine",
        "type": {
          "kind": "struct",
          "name": "rule_engine"
        }
      },
      {
        "name": "exhook",
        "type": {
          "kind": "struct",
          "name": "exhook"
        }
      },
      {
        "name": "psk_authentication",
        "type": {
          "kind": "struct",
          "name": "authn-psk:psk_authentication"
        }
      },
      {
        "name": "limiter",
        "type": {
          "kind": "struct",
          "name": "limiter"
        }
      },
      {
        "name": "slow_subs",
        "type": {
          "kind": "struct",
          "name": "slow_subs"
        }
      }
    ],
    "full_name": "Root Config Keys",
    "paths": [],
    "tags": []
  },
  {
    "desc": "Settings for the alarms.",
    "fields": [
      {
        "default": {
          "hocon": "[log, publish]",
          "oneliner": true
        },
        "desc": "The actions triggered when the alarm is activated.<br/>Currently, the following actions are supported: <code>log</code> and <code>publish</code>.\n<code>log</code> is to write the alarm to log (console or file).\n<code>publish</code> is to publish the alarm as an MQTT message to the system topics:\n<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/activate</code> and\n<code>$SYS/brokers/emqx@xx.xx.xx.x/alarms/deactivate</code>",
        "examples": [
          [
            "log",
            "publish"
          ]
        ],
        "name": "actions",
        "raw_default": [
          "log",
          "publish"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "atom()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "1000",
          "oneliner": true
        },
        "desc": "The maximum total number of deactivated alarms to keep as history.<br/>When this limit is exceeded, the oldest deactivated alarms are deleted to cap the total number.\n",
        "examples": [
          1000
        ],
        "name": "size_limit",
        "raw_default": 1000,
        "type": {
          "kind": "primitive",
          "name": "1..3000"
        }
      },
      {
        "default": {
          "hocon": "\"24h\"",
          "oneliner": true
        },
        "desc": "Retention time of deactivated alarms. Alarms are not deleted immediately\nwhen deactivated, but after the retention time.\n",
        "examples": [
          [
            50,
            52,
            104
          ]
        ],
        "name": "validity_period",
        "raw_default": [
          50,
          52,
          104
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      }
    ],
    "full_name": "broker:alarm",
    "paths": [
      "alarm"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Message broker options.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable session registry",
        "name": "enable_session_registry",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "quorum",
          "oneliner": true
        },
        "desc": "Session locking strategy in a cluster.\n  - `local`: only lock the session on the current node\n  - `one`: select only one remote node to lock the session\n  - `quorum`: select some nodes to lock the session\n  - `all`: lock the session on all the nodes in the cluster\n",
        "name": "session_locking_strategy",
        "raw_default": "quorum",
        "type": {
          "kind": "enum",
          "symbols": [
            "local",
            "leader",
            "quorum",
            "all"
          ]
        }
      },
      {
        "default": {
          "hocon": "round_robin",
          "oneliner": true
        },
        "desc": "Dispatch strategy for shared subscription.\n  - `random`: dispatch the message to a random selected subscriber\n  - `round_robin`: select the subscribers in a round-robin manner\n  - `sticky`: always use the last selected subscriber to dispatch, until the subscriber disconnects.\n  - `hash`: select the subscribers by the hash of `clientIds`\n",
        "name": "shared_subscription_strategy",
        "raw_default": "round_robin",
        "type": {
          "kind": "enum",
          "symbols": [
            "random",
            "round_robin",
            "round_robin_per_group",
            "sticky",
            "local",
            "hash_topic",
            "hash_clientid"
          ]
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Enable/disable shared dispatch acknowledgement for QoS 1 and QoS 2 messages.\nThis should allow messages to be dispatched to a different subscriber in the group in case the picked (based on `shared_subscription_strategy`) subscriber is offline.\n",
        "name": "shared_dispatch_ack_enabled",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable batch clean for deleted routes.",
        "name": "route_batch_clean",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "name": "perf",
        "type": {
          "kind": "struct",
          "name": "broker:broker_perf"
        }
      },
      {
        "desc": "Per group dispatch strategy for shared subscription.\nThis config is a map from shared subscription group name to the strategy\nname. The group name should be of format `[A-Za-z0-9]`. i.e. no\nspecial characters are allowed.\n",
        "examples": [
          {
            "example_group": {
              "strategy": "random"
            }
          }
        ],
        "name": "shared_subscription_group",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "broker:shared_subscription_group"
          }
        }
      }
    ],
    "full_name": "broker",
    "paths": [
      "broker"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Broker performance tuning parameters.",
    "fields": [
      {
        "default": {
          "hocon": "key",
          "oneliner": true
        },
        "desc": "Performance tuning for subscribing/unsubscribing a wildcard topic.\nChange this parameter only when there are many wildcard topics.\n\nNOTE: when changing from/to `global` lock, it requires all nodes in the cluster to be stopped before the change.\n  - `key`: mnesia transactional updates with per-key locks. Recommended for a single-node setup.\n  - `tab`: mnesia transactional updates with table lock. Recommended for a cluster setup.\n  - `global`: updates are protected with a global lock. Recommended for large clusters.\n",
        "name": "route_lock_type",
        "raw_default": "key",
        "type": {
          "kind": "enum",
          "symbols": [
            "key",
            "tab",
            "global"
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable trie path compaction.\nEnabling it significantly improves wildcard topic subscribe rate, if wildcard topics have unique prefixes like: 'sensor/{{id}}/+/', where ID is unique per subscriber.\nTopic match performance (when publishing) may degrade if messages are mostly published to topics with large number of levels.\n\nNOTE: This is a cluster-wide configuration. It requires all nodes to be stopped before changing it.\n",
        "name": "trie_compaction",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "broker:broker_perf",
    "paths": [
      "broker.perf"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Settings for the authorization cache.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable or disable the authorization cache.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "32",
          "oneliner": true
        },
        "desc": "Maximum number of cached items.",
        "name": "max_size",
        "raw_default": 32,
        "type": {
          "kind": "primitive",
          "name": "1..1048576"
        }
      },
      {
        "default": {
          "hocon": "\"1m\"",
          "oneliner": true
        },
        "desc": "Time to live for the cached data.  ",
        "name": "ttl",
        "raw_default": [
          49,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      }
    ],
    "full_name": "broker:cache",
    "paths": [
      "authorization.cache"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Settings for `conn_congestion` alarm.\n\nSometimes the MQTT connection (usually an MQTT subscriber) may\nget \"congested\", because there are too many packets to be sent.\nThe socket tries to buffer the packets until the buffer is\nfull. If more packets arrive after that, the packets will be\n\"pending\" in the queue, and we consider the connection\ncongested.\n\nNote: `sndbuf` can be set to larger value if the\nalarm is triggered too often.\nThe name of the alarm is of format `conn_congestion/<ClientID>/<Username>`,\nwhere the `<ClientID>` is the client ID of the congested MQTT connection,\nand `<Username>` is the username or `unknown_user`.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable or disable connection congestion alarm.",
        "name": "enable_alarm",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"1m\"",
          "oneliner": true
        },
        "desc": "Minimal time before clearing the alarm.<br/>The alarm is cleared only when there's no pending data in<br/>the queue, and at least <code>min_alarm_sustain_duration</code>milliseconds passed since the last time we considered the connection 'congested'.<br/>This is to avoid clearing and raising the alarm again too often.",
        "name": "min_alarm_sustain_duration",
        "raw_default": [
          49,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      }
    ],
    "full_name": "broker:conn_congestion",
    "paths": [
      "conn_congestion"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Compression options.",
    "fields": [
      {
        "desc": "Compression level. ",
        "name": "level",
        "type": {
          "kind": "enum",
          "symbols": [
            "none",
            "default",
            "best_compression",
            "best_speed"
          ]
        }
      },
      {
        "default": {
          "hocon": "8",
          "oneliner": true
        },
        "desc": "\nSpecifies the size of the compression state.<br/>\nLower values decrease memory usage per connection.\n",
        "name": "mem_level",
        "raw_default": 8,
        "type": {
          "kind": "primitive",
          "name": "1..9"
        }
      },
      {
        "default": {
          "hocon": "default",
          "oneliner": true
        },
        "desc": "Specifies the compression strategy.",
        "name": "strategy",
        "raw_default": "default",
        "type": {
          "kind": "enum",
          "symbols": [
            "default",
            "filtered",
            "huffman_only",
            "rle"
          ]
        }
      },
      {
        "default": {
          "hocon": "takeover",
          "oneliner": true
        },
        "desc": "Takeover means the compression state is retained between server messages. ",
        "name": "server_context_takeover",
        "raw_default": "takeover",
        "type": {
          "kind": "enum",
          "symbols": [
            "takeover",
            "no_takeover"
          ]
        }
      },
      {
        "default": {
          "hocon": "takeover",
          "oneliner": true
        },
        "desc": "Takeover means the compression state is retained between client messages. ",
        "name": "client_context_takeover",
        "raw_default": "takeover",
        "type": {
          "kind": "enum",
          "symbols": [
            "takeover",
            "no_takeover"
          ]
        }
      },
      {
        "default": {
          "hocon": "15",
          "oneliner": true
        },
        "desc": "Specifies the size of the compression context for the server.",
        "name": "server_max_window_bits",
        "raw_default": 15,
        "type": {
          "kind": "primitive",
          "name": "8..15"
        }
      },
      {
        "default": {
          "hocon": "15",
          "oneliner": true
        },
        "desc": "Specifies the size of the compression context for the client.",
        "name": "client_max_window_bits",
        "raw_default": 15,
        "type": {
          "kind": "primitive",
          "name": "8..15"
        }
      }
    ],
    "full_name": "broker:deflate_opts",
    "paths": [
      "listeners.ws.$name.websocket.deflate_opts",
      "listeners.wss.$name.websocket.deflate_opts"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Enable or disable client lifecycle event publishing.\n\nThe following options affect MQTT clients as well as\ngateway clients. The types of the clients\nare distinguished by the topic prefix:\n\n- For the MQTT clients, the format is:\n`$SYS/broker/<node>/clients/<clientid>/<event>`\n- For the Gateway clients, it is\n`$SYS/broker/<node>/gateway/<gateway-name>/clients/<clientid>/<event>`\n",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable to publish client connected event messages",
        "name": "client_connected",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable to publish client disconnected event messages.",
        "name": "client_disconnected",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Enable to publish event message that client subscribed a topic successfully.",
        "name": "client_subscribed",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Enable to publish event message that client unsubscribed a topic successfully.",
        "name": "client_unsubscribed",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "broker:event_names",
    "paths": [
      "sys_topics.sys_event_messages"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "This config controls the allowed maximum number of `CONNECT` packets received\nfrom the same clientid in a time frame defined by `window_time`.\nAfter the limit is reached, successive `CONNECT` requests are forbidden\n(banned) until the end of the time period defined by `ban_time`.",
    "fields": [
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Enable flapping connection detection feature.",
        "name": "enable",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "15",
          "oneliner": true
        },
        "desc": "The maximum number of disconnects allowed for a MQTT Client in `window_time`",
        "name": "max_count",
        "raw_default": 15,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "\"1m\"",
          "oneliner": true
        },
        "desc": "The time window for flapping detection.",
        "name": "window_time",
        "raw_default": [
          49,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"5m\"",
          "oneliner": true
        },
        "desc": "How long the flapping clientid will be banned.",
        "name": "ban_time",
        "raw_default": [
          53,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      }
    ],
    "full_name": "broker:flapping_detect",
    "paths": [
      "flapping_detect"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Force garbage collection in MQTT connection process after\n they process certain number of messages or bytes of data.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable forced garbage collection.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "16000",
          "oneliner": true
        },
        "desc": "GC the process after this many received messages.",
        "name": "count",
        "raw_default": 16000,
        "type": {
          "kind": "primitive",
          "name": "0..inf"
        }
      },
      {
        "default": {
          "hocon": "\"16MB\"",
          "oneliner": true
        },
        "desc": "GC the process after specified number of bytes have passed through.",
        "name": "bytes",
        "raw_default": [
          49,
          54,
          77,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      }
    ],
    "full_name": "broker:force_gc",
    "paths": [
      "force_gc"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "When the process message queue length, or the memory bytes\nreaches a certain value, the process is forced to close.\n\nNote: \"message queue\" here refers to the \"message mailbox\"\nof the Erlang process, not the `mqueue` of QoS 1 and QoS 2.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable `force_shutdown` feature.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "1000",
          "oneliner": true
        },
        "desc": "Maximum message queue length.",
        "name": "max_message_queue_len",
        "raw_default": 1000,
        "type": {
          "kind": "primitive",
          "name": "0..inf"
        }
      },
      {
        "default": {
          "hocon": "\"32MB\"",
          "oneliner": true
        },
        "desc": "Total heap size",
        "name": "max_heap_size",
        "raw_default": [
          51,
          50,
          77,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:wordsize()"
        }
      }
    ],
    "full_name": "broker:force_shutdown",
    "paths": [
      "force_shutdown"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Socket options for SSL connections.",
    "fields": [
      {
        "desc": "\nTrusted PEM format CA certificates bundle file.<br/>\nThe certificates in this file are used to verify the TLS peer's certificates.\nAppend new certificates to the file if new CAs are to be trusted.\nThere is no need to restart EMQX to have the updated file loaded, because\nthe system regularly checks if file has been updated (and reload).<br/>\nNOTE: invalidating (deleting) a certificate from the file will not affect\nalready established connections.\n",
        "name": "cacertfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "\nPEM format certificates chain file.<br/>\nThe certificates in this file should be in reversed order of the certificate\nissue chain. That is, the host's certificate should be placed in the beginning\nof the file, followed by the immediate issuer certificate and so on.\nAlthough the root CA certificate is optional, it should be placed at the end of\nthe file if it is to be added.\n",
        "name": "certfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "PEM format private key file. ",
        "name": "keyfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "verify_none",
          "oneliner": true
        },
        "desc": "Enable or disable peer verification. ",
        "name": "verify",
        "raw_default": "verify_none",
        "type": {
          "kind": "enum",
          "symbols": [
            "verify_peer",
            "verify_none"
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable TLS session reuse. ",
        "name": "reuse_sessions",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "10",
          "oneliner": true
        },
        "desc": "\nMaximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.\nSo, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/>\nif 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/>\nif 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.<br/>\n",
        "name": "depth",
        "raw_default": 10,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "\nString containing the user's password.\nOnly used if the private key file is password-protected.\n",
        "examples": [
          ""
        ],
        "name": "password",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "[tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]",
          "oneliner": true
        },
        "desc": "\nAll TLS/DTLS versions to be supported.<br/>\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/>\nIn case PSK cipher suites are intended, make sure to configure\n<code>['tlsv1.2', 'tlsv1.1']</code> here.\n",
        "name": "versions",
        "raw_default": [
          "tlsv1.3",
          "tlsv1.2",
          "tlsv1.1",
          "tlsv1"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "atom()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "\nThis config holds TLS cipher suite names separated by comma,\nor as an array of strings. e.g.\n<code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or\n<code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.\n<br/>\nCiphers (and their ordering) define the way in which the\nclient and server encrypts information over the network connection.\nSelecting a good cipher suite is critical for the\napplication's data security, confidentiality and performance.\n\nThe names should be in OpenSSL string format (not RFC format).\nAll default values and examples provided by EMQX config\ndocumentation are all in OpenSSL format.<br/>\n\nNOTE: Certain cipher suites are only compatible with\nspecific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')\nincompatible cipher suites will be silently dropped.\nFor instance, if only 'tlsv1.3' is given in the <code>versions</code>,\nconfiguring cipher suites for other versions will have no effect.\n<br/>\n\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/>\nIf PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/>\nPSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,\nRSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,\nRSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,\nRSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/>\n",
        "name": "ciphers",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "\"emqx_tls_psk:lookup\"",
          "oneliner": true
        },
        "desc": "EMQX-internal callback that is used to lookup pre-shared key (PSK) identity. ",
        "name": "user_lookup_fun",
        "raw_default": "emqx_tls_psk:lookup",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nSSL parameter renegotiation is a feature that allows a client and a server\nto renegotiate the parameters of the SSL connection on the fly.\nRFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,\nyou drop support for the insecure renegotiation, prone to MitM attacks.\n",
        "name": "secure_renegotiate",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "\nPath to a file containing PEM-encoded Diffie-Hellman parameters\nto be used by the server if a cipher suite using Diffie-Hellman\nkey exchange is negotiated. If not specified, default parameters\nare used.<br/>\nNOTE: The <code>dhfile</code> option is not supported by TLS 1.3.\n",
        "name": "dhfile",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "\nUsed together with {verify, verify_peer} by an TLS/DTLS server.\nIf set to true, the server fails if the client does not have a\ncertificate to send, that is, sends an empty certificate.\nIf set to false, it fails only if the client sends an invalid\ncertificate (an empty certificate is considered valid).\n",
        "name": "fail_if_no_peer_cert",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nAn important security setting, it forces the cipher to be set based\n on the server-specified order instead of the client-specified order,\n hence enforcing the (usually more properly configured) security\n ordering of the server administrator.\n",
        "name": "honor_cipher_order",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nIn protocols that support client-initiated renegotiation,\nthe cost of resources of such an operation is higher for the server than the client.\nThis can act as a vector for denial of service attacks.\nThe SSL application already takes measures to counter-act such attempts,\nbut client-initiated renegotiation can be strictly disabled by setting this option to false.\nThe default value is true. Note that disabling renegotiation can result in\nlong-lived connections becoming unusable due to limits on\nthe number of messages the underlying cipher suite can encipher.\n",
        "name": "client_renegotiation",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"15s\"",
          "oneliner": true
        },
        "desc": "\nMaximum time duration allowed for the handshake to complete\n",
        "name": "handshake_timeout",
        "raw_default": [
          49,
          53,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "\nMemory usage tuning. If enabled, will immediately perform a garbage collection after\nthe TLS/SSL handshake.\n",
        "name": "gc_after_handshake",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "broker:listener_ssl_opts",
    "paths": [
      "gateway.exproto.listeners.ssl.$name.ssl_options",
      "gateway.stomp.listeners.ssl.$name.ssl_options",
      "listeners.ssl.$name.ssl_options"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Socket options for WebSocket/SSL connections.",
    "fields": [
      {
        "desc": "\nTrusted PEM format CA certificates bundle file.<br/>\nThe certificates in this file are used to verify the TLS peer's certificates.\nAppend new certificates to the file if new CAs are to be trusted.\nThere is no need to restart EMQX to have the updated file loaded, because\nthe system regularly checks if file has been updated (and reload).<br/>\nNOTE: invalidating (deleting) a certificate from the file will not affect\nalready established connections.\n",
        "name": "cacertfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "\nPEM format certificates chain file.<br/>\nThe certificates in this file should be in reversed order of the certificate\nissue chain. That is, the host's certificate should be placed in the beginning\nof the file, followed by the immediate issuer certificate and so on.\nAlthough the root CA certificate is optional, it should be placed at the end of\nthe file if it is to be added.\n",
        "name": "certfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "PEM format private key file. ",
        "name": "keyfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "verify_none",
          "oneliner": true
        },
        "desc": "Enable or disable peer verification. ",
        "name": "verify",
        "raw_default": "verify_none",
        "type": {
          "kind": "enum",
          "symbols": [
            "verify_peer",
            "verify_none"
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable TLS session reuse. ",
        "name": "reuse_sessions",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "10",
          "oneliner": true
        },
        "desc": "\nMaximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.\nSo, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/>\nif 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/>\nif 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.<br/>\n",
        "name": "depth",
        "raw_default": 10,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "\nString containing the user's password.\nOnly used if the private key file is password-protected.\n",
        "examples": [
          ""
        ],
        "name": "password",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "[tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]",
          "oneliner": true
        },
        "desc": "\nAll TLS/DTLS versions to be supported.<br/>\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/>\nIn case PSK cipher suites are intended, make sure to configure\n<code>['tlsv1.2', 'tlsv1.1']</code> here.\n",
        "name": "versions",
        "raw_default": [
          "tlsv1.3",
          "tlsv1.2",
          "tlsv1.1",
          "tlsv1"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "atom()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "\nThis config holds TLS cipher suite names separated by comma,\nor as an array of strings. e.g.\n<code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or\n<code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.\n<br/>\nCiphers (and their ordering) define the way in which the\nclient and server encrypts information over the network connection.\nSelecting a good cipher suite is critical for the\napplication's data security, confidentiality and performance.\n\nThe names should be in OpenSSL string format (not RFC format).\nAll default values and examples provided by EMQX config\ndocumentation are all in OpenSSL format.<br/>\n\nNOTE: Certain cipher suites are only compatible with\nspecific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')\nincompatible cipher suites will be silently dropped.\nFor instance, if only 'tlsv1.3' is given in the <code>versions</code>,\nconfiguring cipher suites for other versions will have no effect.\n<br/>\n\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/>\nIf PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/>\nPSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,\nRSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,\nRSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,\nRSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/>\n",
        "name": "ciphers",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "\"emqx_tls_psk:lookup\"",
          "oneliner": true
        },
        "desc": "EMQX-internal callback that is used to lookup pre-shared key (PSK) identity. ",
        "name": "user_lookup_fun",
        "raw_default": "emqx_tls_psk:lookup",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nSSL parameter renegotiation is a feature that allows a client and a server\nto renegotiate the parameters of the SSL connection on the fly.\nRFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,\nyou drop support for the insecure renegotiation, prone to MitM attacks.\n",
        "name": "secure_renegotiate",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "\nPath to a file containing PEM-encoded Diffie-Hellman parameters\nto be used by the server if a cipher suite using Diffie-Hellman\nkey exchange is negotiated. If not specified, default parameters\nare used.<br/>\nNOTE: The <code>dhfile</code> option is not supported by TLS 1.3.\n",
        "name": "dhfile",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "\nUsed together with {verify, verify_peer} by an TLS/DTLS server.\nIf set to true, the server fails if the client does not have a\ncertificate to send, that is, sends an empty certificate.\nIf set to false, it fails only if the client sends an invalid\ncertificate (an empty certificate is considered valid).\n",
        "name": "fail_if_no_peer_cert",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nAn important security setting, it forces the cipher to be set based\n on the server-specified order instead of the client-specified order,\n hence enforcing the (usually more properly configured) security\n ordering of the server administrator.\n",
        "name": "honor_cipher_order",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nIn protocols that support client-initiated renegotiation,\nthe cost of resources of such an operation is higher for the server than the client.\nThis can act as a vector for denial of service attacks.\nThe SSL application already takes measures to counter-act such attempts,\nbut client-initiated renegotiation can be strictly disabled by setting this option to false.\nThe default value is true. Note that disabling renegotiation can result in\nlong-lived connections becoming unusable due to limits on\nthe number of messages the underlying cipher suite can encipher.\n",
        "name": "client_renegotiation",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"15s\"",
          "oneliner": true
        },
        "desc": "\nMaximum time duration allowed for the handshake to complete\n",
        "name": "handshake_timeout",
        "raw_default": [
          49,
          53,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      }
    ],
    "full_name": "broker:listener_wss_opts",
    "paths": [
      "listeners.wss.$name.ssl_options"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "MQTT listeners identified by their protocol type and assigned names",
    "fields": [
      {
        "desc": "TCP listeners.",
        "name": "tcp",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "broker:mqtt_tcp_listener"
          }
        }
      },
      {
        "desc": "SSL listeners.",
        "name": "ssl",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "broker:mqtt_ssl_listener"
          }
        }
      },
      {
        "desc": "HTTP websocket listeners.",
        "name": "ws",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "broker:mqtt_ws_listener"
          }
        }
      },
      {
        "desc": "HTTPS websocket listeners.",
        "name": "wss",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "broker:mqtt_wss_listener"
          }
        }
      },
      {
        "desc": "QUIC listeners.",
        "name": "quic",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "broker:mqtt_quic_listener"
          }
        }
      }
    ],
    "full_name": "broker:listeners",
    "paths": [
      "listeners"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Global MQTT configuration.<br/>The configs here work as default values which can be overridden\nin <code>zone</code> configs",
    "fields": [
      {
        "default": {
          "hocon": "\"15s\"",
          "oneliner": true
        },
        "desc": "After the TCP connection is established, if the MQTT CONNECT packet from the client is not received within the time specified by <code>idle_timeout</code>, the connection will be disconnected.",
        "name": "idle_timeout",
        "raw_default": [
          49,
          53,
          115
        ],
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "infinity"
            },
            {
              "kind": "primitive",
              "name": "emqx_schema:duration()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"1MB\"",
          "oneliner": true
        },
        "desc": "Maximum MQTT packet size allowed.",
        "name": "max_packet_size",
        "raw_default": [
          49,
          77,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "65535",
          "oneliner": true
        },
        "desc": "Maximum allowed length of MQTT Client ID.",
        "name": "max_clientid_len",
        "raw_default": 65535,
        "type": {
          "kind": "primitive",
          "name": "23..65535"
        }
      },
      {
        "default": {
          "hocon": "128",
          "oneliner": true
        },
        "desc": "Maximum topic levels allowed.",
        "name": "max_topic_levels",
        "raw_default": 128,
        "type": {
          "kind": "primitive",
          "name": "1..65535"
        }
      },
      {
        "default": {
          "hocon": "2",
          "oneliner": true
        },
        "desc": "Maximum QoS allowed.",
        "name": "max_qos_allowed",
        "raw_default": 2,
        "type": {
          "kind": "primitive",
          "name": "qos()"
        }
      },
      {
        "default": {
          "hocon": "65535",
          "oneliner": true
        },
        "desc": "Maximum topic alias, 0 means no topic alias supported.",
        "name": "max_topic_alias",
        "raw_default": 65535,
        "type": {
          "kind": "primitive",
          "name": "0..65535"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable support for MQTT retained message.",
        "name": "retain_available",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable support for MQTT wildcard subscription.",
        "name": "wildcard_subscription",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Whether to enable support for MQTT shared subscription.",
        "name": "shared_subscription",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Whether to enable support for MQTT exclusive subscription.",
        "name": "exclusive_subscription",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Ignore loop delivery of messages for MQTT v3.1.1/v3.1.0, similar to <code>No Local</code> subscription option in MQTT 5.0.",
        "name": "ignore_loop_deliver",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Parse MQTT messages in strict mode.\nWhen set to true, invalid utf8 strings in for example client ID, topic name, etc. will cause the client to be disconnected",
        "name": "strict_mode",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"\"",
          "oneliner": true
        },
        "desc": "Specify the response information returned to the client. This feature is disabled if is set to \"\". Applies only to clients using MQTT 5.0.",
        "name": "response_information",
        "raw_default": "",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "disabled",
          "oneliner": true
        },
        "desc": "The keep alive that EMQX requires the client to use. If configured as <code>disabled</code>, it means that the keep alive specified by the client will be used. Requires <code>Server Keep Alive</code> in MQTT 5.0, so it is only applicable to clients using MQTT 5.0 protocol.",
        "name": "server_keepalive",
        "raw_default": "disabled",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "integer()"
            },
            {
              "kind": "singleton",
              "name": "disabled"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "0.75",
          "oneliner": true
        },
        "desc": "The backoff multiplier used by the broker to determine the client keep alive timeout. If EMQX doesn't receive any packet in <code>Keep Alive * Backoff * 2</code> seconds, EMQX will close the current connection.",
        "name": "keepalive_backoff",
        "raw_default": 0.75,
        "type": {
          "kind": "primitive",
          "name": "number()"
        }
      },
      {
        "default": {
          "hocon": "infinity",
          "oneliner": true
        },
        "desc": "Maximum number of subscriptions allowed per client.",
        "name": "max_subscriptions",
        "raw_default": "infinity",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "1..inf"
            },
            {
              "kind": "singleton",
              "name": "infinity"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Force upgrade of QoS level according to subscription.",
        "name": "upgrade_qos",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "32",
          "oneliner": true
        },
        "desc": "Maximum number of QoS 1 and QoS 2 messages that are allowed to be delivered simultaneously before completing the acknowledgment.",
        "name": "max_inflight",
        "raw_default": 32,
        "type": {
          "kind": "primitive",
          "name": "1..65535"
        }
      },
      {
        "default": {
          "hocon": "\"30s\"",
          "oneliner": true
        },
        "desc": "Retry interval for QoS 1/2 message delivering.",
        "name": "retry_interval",
        "raw_default": [
          51,
          48,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "100",
          "oneliner": true
        },
        "desc": "For each publisher session, the maximum number of outstanding QoS 2 messages pending on the client to send PUBREL. After reaching this limit, new QoS 2 PUBLISH requests will be rejected with `147(0x93)` until either PUBREL is received or timed out.",
        "name": "max_awaiting_rel",
        "raw_default": 100,
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "integer()"
            },
            {
              "kind": "singleton",
              "name": "infinity"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"300s\"",
          "oneliner": true
        },
        "desc": "For client to broker QoS 2 message, the time limit for the broker to wait before the `PUBREL` message is received. The wait is aborted after timed out, meaning the packet ID is freed for new `PUBLISH` requests. Receiving a stale `PUBREL` causes a warning level log. Note, the message is delivered to subscribers before entering the wait for PUBREL.",
        "name": "await_rel_timeout",
        "raw_default": [
          51,
          48,
          48,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"2h\"",
          "oneliner": true
        },
        "desc": "Specifies how long the session will expire after the connection is disconnected, only for non-MQTT 5.0 connections.",
        "name": "session_expiry_interval",
        "raw_default": [
          50,
          104
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "1000",
          "oneliner": true
        },
        "desc": "Maximum queue length. Enqueued messages when persistent client disconnected, or inflight window is full.",
        "name": "max_mqueue_len",
        "raw_default": 1000,
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "non_neg_integer()"
            },
            {
              "kind": "singleton",
              "name": "infinity"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "disabled",
          "oneliner": true
        },
        "desc": "Topic priorities. Priority number [1-255]\nThere's no priority table by default, hence all messages are treated equal.\n\n**NOTE**: Comma and equal signs are not allowed for priority topic names.\n**NOTE**: Messages for topics not in the priority table are treated as either highest or lowest priority depending on the configured value for <code>mqtt.mqueue_default_priority</code>.\n\n**Examples**:\nTo configure <code>\"topic/1\" > \"topic/2\"</code>:\n<code>mqueue_priorities: {\"topic/1\": 10, \"topic/2\": 8}</code>\n",
        "name": "mqueue_priorities",
        "raw_default": "disabled",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "map()"
            },
            {
              "kind": "singleton",
              "name": "disabled"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "lowest",
          "oneliner": true
        },
        "desc": "Default topic priority, which will be used by topics not in <code>Topic Priorities</code> (<code>mqueue_priorities</code>).",
        "name": "mqueue_default_priority",
        "raw_default": "lowest",
        "type": {
          "kind": "enum",
          "symbols": [
            "highest",
            "lowest"
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Specifies whether to store QoS 0 messages in the message queue while the connection is down but the session remains.",
        "name": "mqueue_store_qos0",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Whether to user Client ID as Username.\nThis setting takes effect later than <code>Use Peer Certificate as Username</code> (<code>peer_cert_as_username</code>) and <code>Use peer certificate as Client ID</code> (<code>peer_cert_as_clientid</code>).\n",
        "name": "use_username_as_clientid",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "disabled",
          "oneliner": true
        },
        "desc": "Use the CN, DN field in the peer certificate or the entire certificate content as Username. Only works for the TLS connection.\nSupported configurations are the following:\n- <code>cn</code>: Take the CN field of the certificate as Username\n- <code>dn</code>: Take the DN field of the certificate as Username\n- <code>crt</code>: Take the content of the <code>DER</code> or <code>PEM</code> certificate as Username\n- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format as Username\n- <code>md5</code>: Take the MD5 value of the content of the <code>DER</code> or <code>PEM</code> certificate as Username\n",
        "name": "peer_cert_as_username",
        "raw_default": "disabled",
        "type": {
          "kind": "enum",
          "symbols": [
            "disabled",
            "cn",
            "dn",
            "crt",
            "pem",
            "md5"
          ]
        }
      },
      {
        "default": {
          "hocon": "disabled",
          "oneliner": true
        },
        "desc": "Use the CN, DN field in the peer certificate or the entire certificate content as Client ID. Only works for the TLS connection.\nSupported configurations are the following:\n- <code>cn</code>: Take the CN field of the certificate as Client ID\n- <code>dn</code>: Take the DN field of the certificate as Client ID\n- <code>crt</code>: Take the content of the <code>DER</code> or <code>PEM</code> certificate as Client ID\n- <code>pem</code>: Convert <code>DER</code> certificate content to <code>PEM</code> format as Client ID\n- <code>md5</code>: Take the MD5 value of the content of the <code>DER</code> or <code>PEM</code> certificate as Client ID\n",
        "name": "peer_cert_as_clientid",
        "raw_default": "disabled",
        "type": {
          "kind": "enum",
          "symbols": [
            "disabled",
            "cn",
            "dn",
            "crt",
            "pem",
            "md5"
          ]
        }
      }
    ],
    "full_name": "broker:mqtt",
    "paths": [
      "mqtt"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Settings for the MQTT over QUIC listener.",
    "fields": [
      {
        "desc": "Path to the certificate file.",
        "name": "certfile",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "desc": "Path to the secret key file. ",
        "name": "keyfile",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "[\"TLS_AES_256_GCM_SHA384\", \"TLS_AES_128_GCM_SHA256\", \"TLS_CHACHA20_POLY1305_SHA256\"]",
          "oneliner": true
        },
        "desc": "\nThis config holds TLS cipher suite names separated by comma,\nor as an array of strings. e.g.\n<code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or\n<code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.\n<br/>\nCiphers (and their ordering) define the way in which the\nclient and server encrypts information over the network connection.\nSelecting a good cipher suite is critical for the\napplication's data security, confidentiality and performance.\n\nThe names should be in OpenSSL string format (not RFC format).\nAll default values and examples provided by EMQX config\ndocumentation are all in OpenSSL format.<br/>\n\nNOTE: Certain cipher suites are only compatible with\nspecific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')\nincompatible cipher suites will be silently dropped.\nFor instance, if only 'tlsv1.3' is given in the <code>versions</code>,\nconfiguring cipher suites for other versions will have no effect.\n<br/>\n\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/>\nIf PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/>\nPSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,\nRSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,\nRSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,\nRSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/>\n\nNOTE: QUIC listener supports only 'tlsv1.3' ciphers<br/>\n",
        "name": "ciphers",
        "raw_default": [
          "TLS_AES_256_GCM_SHA384",
          "TLS_AES_128_GCM_SHA256",
          "TLS_CHACHA20_POLY1305_SHA256"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "0",
          "oneliner": true
        },
        "desc": "How long a connection can go idle before it is gracefully shut down. 0 to disable",
        "name": "idle_timeout",
        "raw_default": 0,
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration_ms()"
        }
      },
      {
        "default": {
          "hocon": "\"10s\"",
          "oneliner": true
        },
        "desc": "How long a handshake can idle before it is discarded. ",
        "name": "handshake_idle_timeout",
        "raw_default": [
          49,
          48,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration_ms()"
        }
      },
      {
        "default": {
          "hocon": "0",
          "oneliner": true
        },
        "desc": "\nHow often to send PING frames to keep a connection alive. 0 means disabled.\n",
        "name": "keep_alive_interval",
        "raw_default": 0,
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration_ms()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable listener. ",
        "name": "enabled",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "14567",
          "oneliner": true
        },
        "desc": "\nIP address and port for the listening socket.\n",
        "name": "bind",
        "raw_default": 14567,
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_schema:ip_port()"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "16",
          "oneliner": true
        },
        "desc": "The size of the listener's receiving pool.",
        "name": "acceptors",
        "raw_default": 16,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "default": {
          "hocon": "infinity",
          "oneliner": true
        },
        "desc": "The maximum number of concurrent connections allowed by the listener. ",
        "name": "max_connections",
        "raw_default": "infinity",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "infinity"
            },
            {
              "kind": "primitive",
              "name": "pos_integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"\"",
          "oneliner": true
        },
        "desc": "\nWhen publishing or subscribing, prefix all topics with a mountpoint string.\nThe prefixed string will be removed from the topic name when the message\nis delivered to the subscriber. The mountpoint is a way that users can use\nto implement isolation of message routing between different listeners.\nFor example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`\nset to `some_tenant`, then the client actually subscribes to the topic\n`some_tenant/t`. Similarly, if another client B (connected to the same listener\nas the client A) sends a message to topic `t`, the message is routed\nto all the clients subscribed `some_tenant/t`, so client A will receive the\nmessage, with topic name `t`.<br/>\nSet to `\"\"` to disable the feature.<br/>\n\nVariables in mountpoint string:\n  - <code>${clientid}</code>: clientid\n  - <code>${username}</code>: username\n",
        "name": "mountpoint",
        "raw_default": "",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "default",
          "oneliner": true
        },
        "desc": "\nThe configuration zone to which the listener belongs.\n",
        "name": "zone",
        "raw_default": "default",
        "type": {
          "kind": "primitive",
          "name": "atom()"
        }
      },
      {
        "default": {
          "hocon": "{\n  connection {capacity = 1000, rate = \"1000/s\"}\n}\n",
          "oneliner": false
        },
        "desc": "\nType of the rate limit.\n",
        "name": "limiter",
        "raw_default": {
          "connection": {
            "capacity": 1000,
            "rate": "1000/s"
          }
        },
        "type": {
          "kind": "struct",
          "name": "limiter:listener_fields"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nSet <code>true</code> (default) to enable client authentication on this listener, the authentication\nprocess goes through the configured authentication chain.\nWhen set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.\nWhen set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code> but clients will be\ndenied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off\nanonymous clients early.\n",
        "name": "enable_authn",
        "raw_default": true,
        "type": {
          "kind": "enum",
          "symbols": [
            "true",
            "false",
            "quick_deny_anonymous"
          ]
        }
      }
    ],
    "full_name": "broker:mqtt_quic_listener",
    "paths": [
      "listeners.quic.$name"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Settings for the MQTT over SSL listener.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable listener. ",
        "name": "enabled",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "8883",
          "oneliner": true
        },
        "desc": "\nIP address and port for the listening socket.\n",
        "name": "bind",
        "raw_default": 8883,
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_schema:ip_port()"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "16",
          "oneliner": true
        },
        "desc": "The size of the listener's receiving pool.",
        "name": "acceptors",
        "raw_default": 16,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "default": {
          "hocon": "infinity",
          "oneliner": true
        },
        "desc": "The maximum number of concurrent connections allowed by the listener. ",
        "name": "max_connections",
        "raw_default": "infinity",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "infinity"
            },
            {
              "kind": "primitive",
              "name": "pos_integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"\"",
          "oneliner": true
        },
        "desc": "\nWhen publishing or subscribing, prefix all topics with a mountpoint string.\nThe prefixed string will be removed from the topic name when the message\nis delivered to the subscriber. The mountpoint is a way that users can use\nto implement isolation of message routing between different listeners.\nFor example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`\nset to `some_tenant`, then the client actually subscribes to the topic\n`some_tenant/t`. Similarly, if another client B (connected to the same listener\nas the client A) sends a message to topic `t`, the message is routed\nto all the clients subscribed `some_tenant/t`, so client A will receive the\nmessage, with topic name `t`.<br/>\nSet to `\"\"` to disable the feature.<br/>\n\nVariables in mountpoint string:\n  - <code>${clientid}</code>: clientid\n  - <code>${username}</code>: username\n",
        "name": "mountpoint",
        "raw_default": "",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "default",
          "oneliner": true
        },
        "desc": "\nThe configuration zone to which the listener belongs.\n",
        "name": "zone",
        "raw_default": "default",
        "type": {
          "kind": "primitive",
          "name": "atom()"
        }
      },
      {
        "default": {
          "hocon": "{\n  connection {capacity = 1000, rate = \"1000/s\"}\n}\n",
          "oneliner": false
        },
        "desc": "\nType of the rate limit.\n",
        "name": "limiter",
        "raw_default": {
          "connection": {
            "capacity": 1000,
            "rate": "1000/s"
          }
        },
        "type": {
          "kind": "struct",
          "name": "limiter:listener_fields"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nSet <code>true</code> (default) to enable client authentication on this listener, the authentication\nprocess goes through the configured authentication chain.\nWhen set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.\nWhen set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code> but clients will be\ndenied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off\nanonymous clients early.\n",
        "name": "enable_authn",
        "raw_default": true,
        "type": {
          "kind": "enum",
          "symbols": [
            "true",
            "false",
            "quick_deny_anonymous"
          ]
        }
      },
      {
        "default": {
          "hocon": "[\"allow all\"]",
          "oneliner": true
        },
        "desc": "\nThe access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny\n",
        "name": "access_rules",
        "raw_default": [
          "allow all"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "\nEnable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/>\nSee: https://www.haproxy.com/blog/haproxy/proxy-protocol/\n",
        "name": "proxy_protocol",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"3s\"",
          "oneliner": true
        },
        "desc": "\nTimeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.\n",
        "name": "proxy_protocol_timeout",
        "raw_default": [
          51,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "desc": "\nPer-listener authentication override.\nAuthentication can be one single authenticator instance or a chain of authenticators as an array.\nWhen authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.<br/>\n\n",
        "name": "authentication",
        "type": {
          "elements": {
            "kind": "union",
            "members": [
              {
                "kind": "struct",
                "name": "authn-builtin_db:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-mysql:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-postgresql:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:standalone"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:replica-set"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:sharded-cluster"
              },
              {
                "kind": "struct",
                "name": "authn-redis:standalone"
              },
              {
                "kind": "struct",
                "name": "authn-redis:cluster"
              },
              {
                "kind": "struct",
                "name": "authn-redis:sentinel"
              },
              {
                "kind": "struct",
                "name": "authn-http:get"
              },
              {
                "kind": "struct",
                "name": "authn-http:post"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:hmac-based"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:public-key"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:jwks"
              },
              {
                "kind": "struct",
                "name": "authn-scram-builtin_db:authentication"
              }
            ]
          },
          "kind": "array"
        }
      },
      {
        "name": "tcp_options",
        "type": {
          "kind": "struct",
          "name": "broker:tcp_opts"
        }
      },
      {
        "name": "ssl_options",
        "type": {
          "kind": "struct",
          "name": "broker:listener_ssl_opts"
        }
      }
    ],
    "full_name": "broker:mqtt_ssl_listener",
    "paths": [
      "listeners.ssl.$name"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Settings for the MQTT over TCP listener.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable listener. ",
        "name": "enabled",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "1883",
          "oneliner": true
        },
        "desc": "\nIP address and port for the listening socket.\n",
        "name": "bind",
        "raw_default": 1883,
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_schema:ip_port()"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "16",
          "oneliner": true
        },
        "desc": "The size of the listener's receiving pool.",
        "name": "acceptors",
        "raw_default": 16,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "default": {
          "hocon": "infinity",
          "oneliner": true
        },
        "desc": "The maximum number of concurrent connections allowed by the listener. ",
        "name": "max_connections",
        "raw_default": "infinity",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "infinity"
            },
            {
              "kind": "primitive",
              "name": "pos_integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"\"",
          "oneliner": true
        },
        "desc": "\nWhen publishing or subscribing, prefix all topics with a mountpoint string.\nThe prefixed string will be removed from the topic name when the message\nis delivered to the subscriber. The mountpoint is a way that users can use\nto implement isolation of message routing between different listeners.\nFor example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`\nset to `some_tenant`, then the client actually subscribes to the topic\n`some_tenant/t`. Similarly, if another client B (connected to the same listener\nas the client A) sends a message to topic `t`, the message is routed\nto all the clients subscribed `some_tenant/t`, so client A will receive the\nmessage, with topic name `t`.<br/>\nSet to `\"\"` to disable the feature.<br/>\n\nVariables in mountpoint string:\n  - <code>${clientid}</code>: clientid\n  - <code>${username}</code>: username\n",
        "name": "mountpoint",
        "raw_default": "",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "default",
          "oneliner": true
        },
        "desc": "\nThe configuration zone to which the listener belongs.\n",
        "name": "zone",
        "raw_default": "default",
        "type": {
          "kind": "primitive",
          "name": "atom()"
        }
      },
      {
        "default": {
          "hocon": "{\n  connection {capacity = 1000, rate = \"1000/s\"}\n}\n",
          "oneliner": false
        },
        "desc": "\nType of the rate limit.\n",
        "name": "limiter",
        "raw_default": {
          "connection": {
            "capacity": 1000,
            "rate": "1000/s"
          }
        },
        "type": {
          "kind": "struct",
          "name": "limiter:listener_fields"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nSet <code>true</code> (default) to enable client authentication on this listener, the authentication\nprocess goes through the configured authentication chain.\nWhen set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.\nWhen set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code> but clients will be\ndenied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off\nanonymous clients early.\n",
        "name": "enable_authn",
        "raw_default": true,
        "type": {
          "kind": "enum",
          "symbols": [
            "true",
            "false",
            "quick_deny_anonymous"
          ]
        }
      },
      {
        "default": {
          "hocon": "[\"allow all\"]",
          "oneliner": true
        },
        "desc": "\nThe access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny\n",
        "name": "access_rules",
        "raw_default": [
          "allow all"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "\nEnable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/>\nSee: https://www.haproxy.com/blog/haproxy/proxy-protocol/\n",
        "name": "proxy_protocol",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"3s\"",
          "oneliner": true
        },
        "desc": "\nTimeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.\n",
        "name": "proxy_protocol_timeout",
        "raw_default": [
          51,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "desc": "\nPer-listener authentication override.\nAuthentication can be one single authenticator instance or a chain of authenticators as an array.\nWhen authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.<br/>\n\n",
        "name": "authentication",
        "type": {
          "elements": {
            "kind": "union",
            "members": [
              {
                "kind": "struct",
                "name": "authn-builtin_db:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-mysql:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-postgresql:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:standalone"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:replica-set"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:sharded-cluster"
              },
              {
                "kind": "struct",
                "name": "authn-redis:standalone"
              },
              {
                "kind": "struct",
                "name": "authn-redis:cluster"
              },
              {
                "kind": "struct",
                "name": "authn-redis:sentinel"
              },
              {
                "kind": "struct",
                "name": "authn-http:get"
              },
              {
                "kind": "struct",
                "name": "authn-http:post"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:hmac-based"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:public-key"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:jwks"
              },
              {
                "kind": "struct",
                "name": "authn-scram-builtin_db:authentication"
              }
            ]
          },
          "kind": "array"
        }
      },
      {
        "name": "tcp_options",
        "type": {
          "kind": "struct",
          "name": "broker:tcp_opts"
        }
      }
    ],
    "full_name": "broker:mqtt_tcp_listener",
    "paths": [
      "listeners.tcp.$name"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Settings for the MQTT over WebSocket listener.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable listener. ",
        "name": "enabled",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "8083",
          "oneliner": true
        },
        "desc": "\nIP address and port for the listening socket.\n",
        "name": "bind",
        "raw_default": 8083,
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_schema:ip_port()"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "16",
          "oneliner": true
        },
        "desc": "The size of the listener's receiving pool.",
        "name": "acceptors",
        "raw_default": 16,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "default": {
          "hocon": "infinity",
          "oneliner": true
        },
        "desc": "The maximum number of concurrent connections allowed by the listener. ",
        "name": "max_connections",
        "raw_default": "infinity",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "infinity"
            },
            {
              "kind": "primitive",
              "name": "pos_integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"\"",
          "oneliner": true
        },
        "desc": "\nWhen publishing or subscribing, prefix all topics with a mountpoint string.\nThe prefixed string will be removed from the topic name when the message\nis delivered to the subscriber. The mountpoint is a way that users can use\nto implement isolation of message routing between different listeners.\nFor example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`\nset to `some_tenant`, then the client actually subscribes to the topic\n`some_tenant/t`. Similarly, if another client B (connected to the same listener\nas the client A) sends a message to topic `t`, the message is routed\nto all the clients subscribed `some_tenant/t`, so client A will receive the\nmessage, with topic name `t`.<br/>\nSet to `\"\"` to disable the feature.<br/>\n\nVariables in mountpoint string:\n  - <code>${clientid}</code>: clientid\n  - <code>${username}</code>: username\n",
        "name": "mountpoint",
        "raw_default": "",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "default",
          "oneliner": true
        },
        "desc": "\nThe configuration zone to which the listener belongs.\n",
        "name": "zone",
        "raw_default": "default",
        "type": {
          "kind": "primitive",
          "name": "atom()"
        }
      },
      {
        "default": {
          "hocon": "{\n  connection {capacity = 1000, rate = \"1000/s\"}\n}\n",
          "oneliner": false
        },
        "desc": "\nType of the rate limit.\n",
        "name": "limiter",
        "raw_default": {
          "connection": {
            "capacity": 1000,
            "rate": "1000/s"
          }
        },
        "type": {
          "kind": "struct",
          "name": "limiter:listener_fields"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nSet <code>true</code> (default) to enable client authentication on this listener, the authentication\nprocess goes through the configured authentication chain.\nWhen set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.\nWhen set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code> but clients will be\ndenied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off\nanonymous clients early.\n",
        "name": "enable_authn",
        "raw_default": true,
        "type": {
          "kind": "enum",
          "symbols": [
            "true",
            "false",
            "quick_deny_anonymous"
          ]
        }
      },
      {
        "default": {
          "hocon": "[\"allow all\"]",
          "oneliner": true
        },
        "desc": "\nThe access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny\n",
        "name": "access_rules",
        "raw_default": [
          "allow all"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "\nEnable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/>\nSee: https://www.haproxy.com/blog/haproxy/proxy-protocol/\n",
        "name": "proxy_protocol",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"3s\"",
          "oneliner": true
        },
        "desc": "\nTimeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.\n",
        "name": "proxy_protocol_timeout",
        "raw_default": [
          51,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "desc": "\nPer-listener authentication override.\nAuthentication can be one single authenticator instance or a chain of authenticators as an array.\nWhen authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.<br/>\n\n",
        "name": "authentication",
        "type": {
          "elements": {
            "kind": "union",
            "members": [
              {
                "kind": "struct",
                "name": "authn-builtin_db:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-mysql:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-postgresql:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:standalone"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:replica-set"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:sharded-cluster"
              },
              {
                "kind": "struct",
                "name": "authn-redis:standalone"
              },
              {
                "kind": "struct",
                "name": "authn-redis:cluster"
              },
              {
                "kind": "struct",
                "name": "authn-redis:sentinel"
              },
              {
                "kind": "struct",
                "name": "authn-http:get"
              },
              {
                "kind": "struct",
                "name": "authn-http:post"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:hmac-based"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:public-key"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:jwks"
              },
              {
                "kind": "struct",
                "name": "authn-scram-builtin_db:authentication"
              }
            ]
          },
          "kind": "array"
        }
      },
      {
        "name": "tcp_options",
        "type": {
          "kind": "struct",
          "name": "broker:tcp_opts"
        }
      },
      {
        "name": "websocket",
        "type": {
          "kind": "struct",
          "name": "broker:ws_opts"
        }
      }
    ],
    "full_name": "broker:mqtt_ws_listener",
    "paths": [
      "listeners.ws.$name"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Settings for the MQTT over WebSocket/SSL listener.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable listener. ",
        "name": "enabled",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "8084",
          "oneliner": true
        },
        "desc": "\nIP address and port for the listening socket.\n",
        "name": "bind",
        "raw_default": 8084,
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_schema:ip_port()"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "16",
          "oneliner": true
        },
        "desc": "The size of the listener's receiving pool.",
        "name": "acceptors",
        "raw_default": 16,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "default": {
          "hocon": "infinity",
          "oneliner": true
        },
        "desc": "The maximum number of concurrent connections allowed by the listener. ",
        "name": "max_connections",
        "raw_default": "infinity",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "infinity"
            },
            {
              "kind": "primitive",
              "name": "pos_integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"\"",
          "oneliner": true
        },
        "desc": "\nWhen publishing or subscribing, prefix all topics with a mountpoint string.\nThe prefixed string will be removed from the topic name when the message\nis delivered to the subscriber. The mountpoint is a way that users can use\nto implement isolation of message routing between different listeners.\nFor example if a client A subscribes to `t` with `listeners.tcp.\\<name>.mountpoint`\nset to `some_tenant`, then the client actually subscribes to the topic\n`some_tenant/t`. Similarly, if another client B (connected to the same listener\nas the client A) sends a message to topic `t`, the message is routed\nto all the clients subscribed `some_tenant/t`, so client A will receive the\nmessage, with topic name `t`.<br/>\nSet to `\"\"` to disable the feature.<br/>\n\nVariables in mountpoint string:\n  - <code>${clientid}</code>: clientid\n  - <code>${username}</code>: username\n",
        "name": "mountpoint",
        "raw_default": "",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "default",
          "oneliner": true
        },
        "desc": "\nThe configuration zone to which the listener belongs.\n",
        "name": "zone",
        "raw_default": "default",
        "type": {
          "kind": "primitive",
          "name": "atom()"
        }
      },
      {
        "default": {
          "hocon": "{\n  connection {capacity = 1000, rate = \"1000/s\"}\n}\n",
          "oneliner": false
        },
        "desc": "\nType of the rate limit.\n",
        "name": "limiter",
        "raw_default": {
          "connection": {
            "capacity": 1000,
            "rate": "1000/s"
          }
        },
        "type": {
          "kind": "struct",
          "name": "limiter:listener_fields"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nSet <code>true</code> (default) to enable client authentication on this listener, the authentication\nprocess goes through the configured authentication chain.\nWhen set to <code>false</code> to allow any clients with or without authentication information such as username or password to log in.\nWhen set to <code>quick_deny_anonymous</code>, it behaves like when set to <code>true</code> but clients will be\ndenied immediately without going through any authenticators if <code>username</code> is not provided. This is useful to fence off\nanonymous clients early.\n",
        "name": "enable_authn",
        "raw_default": true,
        "type": {
          "kind": "enum",
          "symbols": [
            "true",
            "false",
            "quick_deny_anonymous"
          ]
        }
      },
      {
        "default": {
          "hocon": "[\"allow all\"]",
          "oneliner": true
        },
        "desc": "\nThe access control rules for this listener.<br/>See: https://github.com/emqtt/esockd#allowdeny\n",
        "name": "access_rules",
        "raw_default": [
          "allow all"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "\nEnable the Proxy Protocol V1/2 if the EMQX cluster is deployed behind HAProxy or Nginx.<br/>\nSee: https://www.haproxy.com/blog/haproxy/proxy-protocol/\n",
        "name": "proxy_protocol",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"3s\"",
          "oneliner": true
        },
        "desc": "\nTimeout for proxy protocol. EMQX will close the TCP connection if proxy protocol packet is not received within the timeout.\n",
        "name": "proxy_protocol_timeout",
        "raw_default": [
          51,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "desc": "\nPer-listener authentication override.\nAuthentication can be one single authenticator instance or a chain of authenticators as an array.\nWhen authenticating a login (username, client ID, etc.) the authenticators are checked in the configured order.<br/>\n\n",
        "name": "authentication",
        "type": {
          "elements": {
            "kind": "union",
            "members": [
              {
                "kind": "struct",
                "name": "authn-builtin_db:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-mysql:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-postgresql:authentication"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:standalone"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:replica-set"
              },
              {
                "kind": "struct",
                "name": "authn-mongodb:sharded-cluster"
              },
              {
                "kind": "struct",
                "name": "authn-redis:standalone"
              },
              {
                "kind": "struct",
                "name": "authn-redis:cluster"
              },
              {
                "kind": "struct",
                "name": "authn-redis:sentinel"
              },
              {
                "kind": "struct",
                "name": "authn-http:get"
              },
              {
                "kind": "struct",
                "name": "authn-http:post"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:hmac-based"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:public-key"
              },
              {
                "kind": "struct",
                "name": "authn-jwt:jwks"
              },
              {
                "kind": "struct",
                "name": "authn-scram-builtin_db:authentication"
              }
            ]
          },
          "kind": "array"
        }
      },
      {
        "name": "tcp_options",
        "type": {
          "kind": "struct",
          "name": "broker:tcp_opts"
        }
      },
      {
        "name": "ssl_options",
        "type": {
          "kind": "struct",
          "name": "broker:listener_wss_opts"
        }
      },
      {
        "name": "websocket",
        "type": {
          "kind": "struct",
          "name": "broker:ws_opts"
        }
      }
    ],
    "full_name": "broker:mqtt_wss_listener",
    "paths": [
      "listeners.wss.$name"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Overload protection mechanism monitors the load of the system and temporarily\ndisables some features (such as accepting new connections) when the load is high.",
    "fields": [
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "React on system overload or not.",
        "name": "enable",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "1",
          "oneliner": true
        },
        "desc": "When at high load, some unimportant tasks could be delayed for execution, here set the duration in milliseconds precision.",
        "name": "backoff_delay",
        "raw_default": 1,
        "type": {
          "kind": "primitive",
          "name": "0..inf"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "When at high load, skip forceful GC.",
        "name": "backoff_gc",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "When at high load, skip process hibernation.",
        "name": "backoff_hibernation",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "When at high load, close new incoming connections.",
        "name": "backoff_new_conn",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "broker:overload_protection",
    "paths": [
      "overload_protection"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Settings for the built-in storage engine of persistent messages.",
    "fields": [
      {
        "default": {
          "hocon": "builtin",
          "oneliner": true
        },
        "desc": "",
        "name": "type",
        "raw_default": "builtin",
        "type": {
          "kind": "enum",
          "symbols": [
            "builtin"
          ]
        }
      },
      {
        "desc": "Performance tuning options for built-in session table.",
        "name": "session",
        "type": {
          "kind": "struct",
          "name": "broker:persistent_table_mria_opts"
        }
      },
      {
        "desc": "Performance tuning options for built-in session messages table.",
        "name": "session_messages",
        "type": {
          "kind": "struct",
          "name": "broker:persistent_table_mria_opts"
        }
      },
      {
        "desc": "Performance tuning options for built-in messages table.",
        "name": "messages",
        "type": {
          "kind": "struct",
          "name": "broker:persistent_table_mria_opts"
        }
      }
    ],
    "full_name": "broker:persistent_session_builtin",
    "paths": [
      "persistent_session_store.backend"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Settings for message persistence.",
    "fields": [
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Use the database to store information about persistent sessions.\nThis makes it possible to migrate a client connection to another\ncluster node if a node is stopped.\n",
        "name": "enabled",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Save information about the persistent sessions on disc.\nIf this option is enabled, persistent sessions will survive full restart of the cluster.\nOtherwise, all the data will be stored in RAM, and it will be lost when all the nodes in the cluster are stopped.",
        "name": "on_disc",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Maintain a copy of the data in RAM for faster access.",
        "name": "ram_cache",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "{\n  messages {ram_cache = \"false\"}\n  session {ram_cache = \"true\"}\n  session_messages {ram_cache = \"true\"}\n  type = \"builtin\"\n}\n",
          "oneliner": false
        },
        "desc": "Database management system used to store information about persistent sessions and messages.\n- `builtin`: Use the embedded database (mria)",
        "name": "backend",
        "raw_default": {
          "messages": {
            "ram_cache": "false"
          },
          "session": {
            "ram_cache": "true"
          },
          "session_messages": {
            "ram_cache": "true"
          },
          "type": "builtin"
        },
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "struct",
              "name": "broker:persistent_session_builtin"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"1h\"",
          "oneliner": true
        },
        "desc": "The time messages that was not delivered to a persistent session\nis stored before being garbage collected if the node the previous\nsession was handled on restarts of is stopped.\n",
        "name": "max_retain_undelivered",
        "raw_default": [
          49,
          104
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"1h\"",
          "oneliner": true
        },
        "desc": "The starting interval for garbage collection of undelivered messages to\na persistent session. This affects how often the \"max_retain_undelivered\"\nis checked for removal.\n",
        "name": "message_gc_interval",
        "raw_default": [
          49,
          104
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"1m\"",
          "oneliner": true
        },
        "desc": "The starting interval for garbage collection of transient data for\npersistent session messages. This does not affect the lifetime length\nof persistent session messages.\n",
        "name": "session_message_gc_interval",
        "raw_default": [
          49,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      }
    ],
    "full_name": "broker:persistent_session_store",
    "paths": [
      "persistent_session_store"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Tuning options for the mria table.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Maintain a copy of the data in RAM for faster access.",
        "name": "ram_cache",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "broker:persistent_table_mria_opts",
    "paths": [
      "persistent_session_store.backend.messages",
      "persistent_session_store.backend.session",
      "persistent_session_store.backend.session_messages"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Per group dispatch strategy for shared subscription",
    "fields": [
      {
        "default": {
          "hocon": "random",
          "oneliner": true
        },
        "desc": "Dispatch strategy for shared subscription.\n- `random`: dispatch the message to a random selected subscriber\n- `round_robin`: select the subscribers in a round-robin manner\n- `round_robin_per_group`: select the subscribers in round-robin fashion within each shared subscriber group\n- `sticky`: always use the last selected subscriber to dispatch,\nuntil the subscriber disconnects.\n- `hash`: select the subscribers by the hash of `clientIds`\n- `local`: send to a random local subscriber. If local\nsubscriber was not found, send to a random subscriber cluster-wide\n",
        "name": "strategy",
        "raw_default": "random",
        "type": {
          "kind": "enum",
          "symbols": [
            "random",
            "round_robin",
            "round_robin_per_group",
            "sticky",
            "local",
            "hash_topic",
            "hash_clientid"
          ]
        }
      }
    ],
    "full_name": "broker:shared_subscription_group",
    "paths": [
      "broker.shared_subscription_group.$name"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Socket options for SSL clients.",
    "fields": [
      {
        "desc": "\nTrusted PEM format CA certificates bundle file.<br/>\nThe certificates in this file are used to verify the TLS peer's certificates.\nAppend new certificates to the file if new CAs are to be trusted.\nThere is no need to restart EMQX to have the updated file loaded, because\nthe system regularly checks if file has been updated (and reload).<br/>\nNOTE: invalidating (deleting) a certificate from the file will not affect\nalready established connections.\n",
        "name": "cacertfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "\nPEM format certificates chain file.<br/>\nThe certificates in this file should be in reversed order of the certificate\nissue chain. That is, the host's certificate should be placed in the beginning\nof the file, followed by the immediate issuer certificate and so on.\nAlthough the root CA certificate is optional, it should be placed at the end of\nthe file if it is to be added.\n",
        "name": "certfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "desc": "PEM format private key file. ",
        "name": "keyfile",
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "verify_none",
          "oneliner": true
        },
        "desc": "Enable or disable peer verification. ",
        "name": "verify",
        "raw_default": "verify_none",
        "type": {
          "kind": "enum",
          "symbols": [
            "verify_peer",
            "verify_none"
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable TLS session reuse. ",
        "name": "reuse_sessions",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "10",
          "oneliner": true
        },
        "desc": "\nMaximum number of non-self-issued intermediate certificates that can follow the peer certificate in a valid certification path.\nSo, if depth is 0 the PEER must be signed by the trusted ROOT-CA directly;<br/>\nif 1 the path can be PEER, Intermediate-CA, ROOT-CA;<br/>\nif 2 the path can be PEER, Intermediate-CA1, Intermediate-CA2, ROOT-CA.<br/>\n",
        "name": "depth",
        "raw_default": 10,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "desc": "\nString containing the user's password.\nOnly used if the private key file is password-protected.\n",
        "examples": [
          ""
        ],
        "name": "password",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "[tlsv1.3, tlsv1.2, tlsv1.1, tlsv1]",
          "oneliner": true
        },
        "desc": "\nAll TLS/DTLS versions to be supported.<br/>\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config.<br/>\nIn case PSK cipher suites are intended, make sure to configure\n<code>['tlsv1.2', 'tlsv1.1']</code> here.\n",
        "name": "versions",
        "raw_default": [
          "tlsv1.3",
          "tlsv1.2",
          "tlsv1.1",
          "tlsv1"
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "atom()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "\nThis config holds TLS cipher suite names separated by comma,\nor as an array of strings. e.g.\n<code>\"TLS_AES_256_GCM_SHA384,TLS_AES_128_GCM_SHA256\"</code> or\n<code>[\"TLS_AES_256_GCM_SHA384\",\"TLS_AES_128_GCM_SHA256\"]</code>.\n<br/>\nCiphers (and their ordering) define the way in which the\nclient and server encrypts information over the network connection.\nSelecting a good cipher suite is critical for the\napplication's data security, confidentiality and performance.\n\nThe names should be in OpenSSL string format (not RFC format).\nAll default values and examples provided by EMQX config\ndocumentation are all in OpenSSL format.<br/>\n\nNOTE: Certain cipher suites are only compatible with\nspecific TLS <code>versions</code> ('tlsv1.1', 'tlsv1.2' or 'tlsv1.3')\nincompatible cipher suites will be silently dropped.\nFor instance, if only 'tlsv1.3' is given in the <code>versions</code>,\nconfiguring cipher suites for other versions will have no effect.\n<br/>\n\nNOTE: PSK ciphers are suppressed by 'tlsv1.3' version config<br/>\nIf PSK cipher suites are intended, 'tlsv1.3' should be disabled from <code>versions</code>.<br/>\nPSK cipher suites: <code>\"RSA-PSK-AES256-GCM-SHA384,RSA-PSK-AES256-CBC-SHA384,\nRSA-PSK-AES128-GCM-SHA256,RSA-PSK-AES128-CBC-SHA256,\nRSA-PSK-AES256-CBC-SHA,RSA-PSK-AES128-CBC-SHA,\nRSA-PSK-DES-CBC3-SHA,RSA-PSK-RC4-SHA\"</code><br/>\n",
        "name": "ciphers",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "string()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "\"emqx_tls_psk:lookup\"",
          "oneliner": true
        },
        "desc": "EMQX-internal callback that is used to lookup pre-shared key (PSK) identity. ",
        "name": "user_lookup_fun",
        "raw_default": "emqx_tls_psk:lookup",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nSSL parameter renegotiation is a feature that allows a client and a server\nto renegotiate the parameters of the SSL connection on the fly.\nRFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,\nyou drop support for the insecure renegotiation, prone to MitM attacks.\n",
        "name": "secure_renegotiate",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Enable TLS. ",
        "name": "enable",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "\nSpecify the host name to be used in TLS Server Name Indication extension.<br/>\nFor instance, when connecting to \"server.example.net\", the genuine server\nwhich accepts the connection and performs TLS handshake may differ from the\nhost the TLS client initially connects to, e.g. when connecting to an IP address\nor when the host has multiple resolvable DNS records <br/>\nIf not specified, it will default to the host name string which is used\nto establish the connection, unless it is IP addressed used.<br/>\nThe host name is then also used in the host name verification of the peer\ncertificate.<br/> The special value 'disable' prevents the Server Name\nIndication extension from being sent and disables the hostname\nverification check.\n",
        "examples": [
          "disable"
        ],
        "name": "server_name_indication",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "disable"
            },
            {
              "kind": "primitive",
              "name": "string()"
            }
          ]
        }
      }
    ],
    "full_name": "broker:ssl_client_opts",
    "paths": [
      "authentication.$INDEX.ssl",
      "authorization.sources.$INDEX.ssl",
      "bridges.mqtt.$name.ssl",
      "bridges.webhook.$name.ssl",
      "cluster.etcd.ssl",
      "gateway.coap.authentication.ssl",
      "gateway.coap.listeners.dtls.$name.authentication.ssl",
      "gateway.coap.listeners.udp.$name.authentication.ssl",
      "gateway.exproto.authentication.ssl",
      "gateway.exproto.handler.ssl_options",
      "gateway.exproto.listeners.dtls.$name.authentication.ssl",
      "gateway.exproto.listeners.ssl.$name.authentication.ssl",
      "gateway.exproto.listeners.tcp.$name.authentication.ssl",
      "gateway.exproto.listeners.udp.$name.authentication.ssl",
      "gateway.lwm2m.authentication.ssl",
      "gateway.lwm2m.listeners.dtls.$name.authentication.ssl",
      "gateway.lwm2m.listeners.udp.$name.authentication.ssl",
      "gateway.mqttsn.authentication.ssl",
      "gateway.mqttsn.listeners.dtls.$name.authentication.ssl",
      "gateway.mqttsn.listeners.udp.$name.authentication.ssl",
      "gateway.stomp.authentication.ssl",
      "gateway.stomp.listeners.ssl.$name.authentication.ssl",
      "gateway.stomp.listeners.tcp.$name.authentication.ssl",
      "listeners.ssl.$name.authentication.$INDEX.ssl",
      "listeners.tcp.$name.authentication.$INDEX.ssl",
      "listeners.ws.$name.authentication.$INDEX.ssl",
      "listeners.wss.$name.authentication.$INDEX.ssl"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Enable/disable statistic data collection.\nStatistic data such as message receive/send count/rate etc. It provides insights of system performance and helps to diagnose issues. You can find statistic data from the dashboard, or from the '/stats' API.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable/disable statistic data collection.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "broker:stats",
    "paths": [
      "stats"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "The EMQX Broker periodically publishes its own status, message statistics,\nclient online and offline events to the system topic starting with `$SYS/`.\n\nThe following options control the behavior of `$SYS` topics.",
    "fields": [
      {
        "default": {
          "hocon": "\"1m\"",
          "oneliner": true
        },
        "desc": "Time interval of publishing `$SYS` messages.",
        "name": "sys_msg_interval",
        "raw_default": [
          49,
          109
        ],
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "disabled"
            },
            {
              "kind": "primitive",
              "name": "emqx_schema:duration()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"30s\"",
          "oneliner": true
        },
        "desc": "Time interval for publishing following heartbeat messages:\n  - `$SYS/brokers/<node>/uptime`\n  - `$SYS/brokers/<node>/datetime`\n",
        "name": "sys_heartbeat_interval",
        "raw_default": [
          51,
          48,
          115
        ],
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "disabled"
            },
            {
              "kind": "primitive",
              "name": "emqx_schema:duration()"
            }
          ]
        }
      },
      {
        "desc": "Client events messages.",
        "name": "sys_event_messages",
        "type": {
          "kind": "struct",
          "name": "broker:event_names"
        }
      }
    ],
    "full_name": "broker:sys_topics",
    "paths": [
      "sys_topics"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Features related to system monitoring and introspection.",
    "fields": [
      {
        "name": "vm",
        "type": {
          "kind": "struct",
          "name": "broker:sysmon_vm"
        }
      },
      {
        "name": "os",
        "type": {
          "kind": "struct",
          "name": "broker:sysmon_os"
        }
      },
      {
        "name": "top",
        "type": {
          "kind": "struct",
          "name": "broker:sysmon_top"
        }
      }
    ],
    "full_name": "broker:sysmon",
    "paths": [
      "sysmon"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "This part of the configuration is responsible for monitoring\n the host OS health, such as free memory, disk space, CPU load, etc.",
    "fields": [
      {
        "default": {
          "hocon": "\"60s\"",
          "oneliner": true
        },
        "desc": "The time interval for the periodic CPU check.",
        "name": "cpu_check_interval",
        "raw_default": [
          54,
          48,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"80%\"",
          "oneliner": true
        },
        "desc": "The threshold, as percentage of system CPU load,\n for how much system cpu can be used before the corresponding alarm is raised.",
        "name": "cpu_high_watermark",
        "raw_default": [
          56,
          48,
          37
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:percent()"
        }
      },
      {
        "default": {
          "hocon": "\"60%\"",
          "oneliner": true
        },
        "desc": "The threshold, as percentage of system CPU load,\n for how much system cpu can be used before the corresponding alarm is cleared.",
        "name": "cpu_low_watermark",
        "raw_default": [
          54,
          48,
          37
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:percent()"
        }
      },
      {
        "default": {
          "hocon": "\"60s\"",
          "oneliner": true
        },
        "desc": "The time interval for the periodic memory check.",
        "name": "mem_check_interval",
        "raw_default": [
          54,
          48,
          115
        ],
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "disabled"
            },
            {
              "kind": "primitive",
              "name": "emqx_schema:duration()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"70%\"",
          "oneliner": true
        },
        "desc": "The threshold, as percentage of system memory,\n for how much system memory can be allocated before the corresponding alarm is raised.",
        "name": "sysmem_high_watermark",
        "raw_default": [
          55,
          48,
          37
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:percent()"
        }
      },
      {
        "default": {
          "hocon": "\"5%\"",
          "oneliner": true
        },
        "desc": "The threshold, as percentage of system memory,\n for how much system memory can be allocated by one Erlang process before\n the corresponding alarm is raised.",
        "name": "procmem_high_watermark",
        "raw_default": [
          53,
          37
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:percent()"
        }
      }
    ],
    "full_name": "broker:sysmon_os",
    "paths": [
      "sysmon.os"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "This part of the configuration is responsible for monitoring\n the Erlang processes in the VM. This information can be sent to an external\n PostgreSQL database. This feature is inactive unless the PostgreSQL sink is configured.",
    "fields": [
      {
        "default": {
          "hocon": "10",
          "oneliner": true
        },
        "desc": "The number of top processes per monitoring group",
        "mapping": "system_monitor.top_num_items",
        "name": "num_items",
        "raw_default": 10,
        "type": {
          "kind": "primitive",
          "name": "non_neg_integer()"
        }
      },
      {
        "default": {
          "hocon": "\"2s\"",
          "oneliner": true
        },
        "desc": "Specifies how often process top should be collected",
        "mapping": "system_monitor.top_sample_interval",
        "name": "sample_interval",
        "raw_default": [
          50,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "1000000",
          "oneliner": true
        },
        "desc": "Stop collecting data when the number of processes\nin the VM exceeds this value",
        "mapping": "system_monitor.top_max_procs",
        "name": "max_procs",
        "raw_default": 1000000,
        "type": {
          "kind": "primitive",
          "name": "non_neg_integer()"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "Hostname of the PostgreSQL database that collects the data points",
        "mapping": "system_monitor.db_hostname",
        "name": "db_hostname",
        "raw_default": [],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "5432",
          "oneliner": true
        },
        "desc": "Port of the PostgreSQL database that collects the data points.",
        "mapping": "system_monitor.db_port",
        "name": "db_port",
        "raw_default": 5432,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "\"system_monitor\"",
          "oneliner": true
        },
        "desc": "Username of the PostgreSQL database",
        "mapping": "system_monitor.db_username",
        "name": "db_username",
        "raw_default": [
          115,
          121,
          115,
          116,
          101,
          109,
          95,
          109,
          111,
          110,
          105,
          116,
          111,
          114
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "\"system_monitor_password\"",
          "oneliner": true
        },
        "desc": "EMQX user password in the PostgreSQL database",
        "mapping": "system_monitor.db_password",
        "name": "db_password",
        "raw_default": [
          115,
          121,
          115,
          116,
          101,
          109,
          95,
          109,
          111,
          110,
          105,
          116,
          111,
          114,
          95,
          112,
          97,
          115,
          115,
          119,
          111,
          114,
          100
        ],
        "type": {
          "kind": "primitive",
          "name": "binary()"
        }
      },
      {
        "default": {
          "hocon": "\"postgres\"",
          "oneliner": true
        },
        "desc": "PostgreSQL database name",
        "mapping": "system_monitor.db_name",
        "name": "db_name",
        "raw_default": [
          112,
          111,
          115,
          116,
          103,
          114,
          101,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      }
    ],
    "full_name": "broker:sysmon_top",
    "paths": [
      "sysmon.top"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "This part of the configuration is responsible for collecting\n BEAM VM events, such as long garbage collection, traffic congestion in the inter-broker\n communication, etc.",
    "fields": [
      {
        "default": {
          "hocon": "\"30s\"",
          "oneliner": true
        },
        "desc": "The time interval for the periodic process limit check.",
        "name": "process_check_interval",
        "raw_default": [
          51,
          48,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"80%\"",
          "oneliner": true
        },
        "desc": "The threshold, as percentage of processes, for how many\n processes can simultaneously exist at the local node before the corresponding\n alarm is raised.",
        "name": "process_high_watermark",
        "raw_default": [
          56,
          48,
          37
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:percent()"
        }
      },
      {
        "default": {
          "hocon": "\"60%\"",
          "oneliner": true
        },
        "desc": "The threshold, as percentage of processes, for how many\n processes can simultaneously exist at the local node before the corresponding\n alarm is cleared.",
        "name": "process_low_watermark",
        "raw_default": [
          54,
          48,
          37
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:percent()"
        }
      },
      {
        "default": {
          "hocon": "disabled",
          "oneliner": true
        },
        "desc": "Enable Long GC monitoring.",
        "name": "long_gc",
        "raw_default": "disabled",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "disabled"
            },
            {
              "kind": "primitive",
              "name": "emqx_schema:duration()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"240ms\"",
          "oneliner": true
        },
        "desc": "Enable Long Schedule monitoring.",
        "name": "long_schedule",
        "raw_default": [
          50,
          52,
          48,
          109,
          115
        ],
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "disabled"
            },
            {
              "kind": "primitive",
              "name": "emqx_schema:duration()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"32MB\"",
          "oneliner": true
        },
        "desc": "Enable Large Heap monitoring.",
        "name": "large_heap",
        "raw_default": [
          51,
          50,
          77,
          66
        ],
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "disabled"
            },
            {
              "kind": "primitive",
              "name": "emqx_schema:bytesize()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable Busy Distribution Port monitoring.",
        "name": "busy_dist_port",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable Busy Port monitoring.",
        "name": "busy_port",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "broker:sysmon_vm",
    "paths": [
      "sysmon.vm"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "TCP listener options.",
    "fields": [
      {
        "default": {
          "hocon": "100",
          "oneliner": true
        },
        "desc": "\nSpecify the {active, N} option for this Socket.<br/>\nSee: https://erlang.org/doc/man/inet.html#setopts-2\n",
        "name": "active_n",
        "raw_default": 100,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "1024",
          "oneliner": true
        },
        "desc": "\nTCP backlog defines the maximum length that the queue of\n pending connections can grow to.\n",
        "name": "backlog",
        "raw_default": 1024,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "default": {
          "hocon": "\"15s\"",
          "oneliner": true
        },
        "desc": "The TCP send timeout for the connections. ",
        "name": "send_timeout",
        "raw_default": [
          49,
          53,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nClose the connection if send timeout.\n",
        "name": "send_timeout_close",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "desc": "\nThe TCP receive buffer (OS kernel) for the connections.\n",
        "examples": [
          "2KB"
        ],
        "name": "recbuf",
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "desc": "\nThe TCP send buffer (OS kernel) for the connections.\n",
        "examples": [
          "4KB"
        ],
        "name": "sndbuf",
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "\"4KB\"",
          "oneliner": true
        },
        "desc": "\nThe size of the user-space buffer used by the driver.\n",
        "examples": [
          "4KB"
        ],
        "name": "buffer",
        "raw_default": "4KB",
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "\"1MB\"",
          "oneliner": true
        },
        "desc": "\nThe socket is set to a busy state when the amount of data queued internally\n  by the VM socket implementation reaches this limit.\n",
        "name": "high_watermark",
        "raw_default": [
          49,
          77,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nThe TCP_NODELAY flag for the connections.\n",
        "name": "nodelay",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nThe SO_REUSEADDR flag for the connections.\n",
        "name": "reuseaddr",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "broker:tcp_opts",
    "paths": [
      "gateway.exproto.listeners.ssl.$name.tcp_options",
      "gateway.exproto.listeners.tcp.$name.tcp_options",
      "gateway.stomp.listeners.ssl.$name.tcp_options",
      "gateway.stomp.listeners.tcp.$name.tcp_options",
      "listeners.ssl.$name.tcp_options",
      "listeners.tcp.$name.tcp_options",
      "listeners.ws.$name.tcp_options",
      "listeners.wss.$name.tcp_options"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Real-time filtering logs for the ClientID or Topic or IP for debugging.",
    "fields": [
      {
        "default": {
          "hocon": "text",
          "oneliner": true
        },
        "desc": "\nDetermine the format of the payload format in the trace file.<br/>\n`text`: Text-based protocol or plain text protocol.\n It is recommended when payload is JSON encoded.<br/>\n`hex`: Binary hexadecimal encode. It is recommended when payload is a custom binary protocol.<br/>\n`hidden`: payload is obfuscated as `******`\n\n",
        "name": "payload_encode",
        "raw_default": "text",
        "type": {
          "kind": "enum",
          "symbols": [
            "hex",
            "text",
            "hidden"
          ]
        }
      }
    ],
    "full_name": "broker:trace",
    "paths": [
      "trace"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "WebSocket listener options.",
    "fields": [
      {
        "default": {
          "hocon": "\"/mqtt\"",
          "oneliner": true
        },
        "desc": "\nWebSocket's MQTT protocol path. So the address of EMQX Broker's WebSocket is:\n<code>ws://{ip}:{port}/mqtt</code>\n",
        "name": "mqtt_path",
        "raw_default": [
          47,
          109,
          113,
          116,
          116
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "multiple",
          "oneliner": true
        },
        "desc": "\nWhether a WebSocket message is allowed to contain multiple MQTT packets.\n",
        "name": "mqtt_piggyback",
        "raw_default": "multiple",
        "type": {
          "kind": "enum",
          "symbols": [
            "single",
            "multiple"
          ]
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "\nIf <code>true</code>, compress WebSocket messages using <code>zlib</code>.<br/>\nThe configuration items under <code>deflate_opts</code> belong to the compression-related parameter configuration.\n",
        "name": "compress",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"7200s\"",
          "oneliner": true
        },
        "desc": "\nClose transport-layer connections from the clients that have not sent MQTT CONNECT\nmessage within this interval.\n",
        "name": "idle_timeout",
        "raw_default": [
          55,
          50,
          48,
          48,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "infinity",
          "oneliner": true
        },
        "desc": "\nThe maximum length of a single MQTT packet.\n",
        "name": "max_frame_size",
        "raw_default": "infinity",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "infinity"
            },
            {
              "kind": "primitive",
              "name": "integer()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nIf <code>true</code>, the server will return an error when\n the client does not carry the <code>Sec-WebSocket-Protocol</code> field.\n <br/>Note: WeChat applet needs to disable this verification.\n",
        "name": "fail_if_no_subprotocol",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"mqtt, mqtt-v3, mqtt-v3.1.1, mqtt-v5\"",
          "oneliner": true
        },
        "desc": "\nComma-separated list of supported subprotocols.\n",
        "name": "supported_subprotocols",
        "raw_default": [
          109,
          113,
          116,
          116,
          44,
          32,
          109,
          113,
          116,
          116,
          45,
          118,
          51,
          44,
          32,
          109,
          113,
          116,
          116,
          45,
          118,
          51,
          46,
          49,
          46,
          49,
          44,
          32,
          109,
          113,
          116,
          116,
          45,
          118,
          53
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:comma_separated_list()"
        }
      },
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "\nIf <code>true</code>, <code>origin</code> HTTP header will be\n validated against the list of allowed origins configured in <code>check_origins</code>\n parameter.\n",
        "name": "check_origin_enable",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "\nIf <code>false</code> and <code>check_origin_enable</code> is\n <code>true</code>, the server will reject requests that don't have <code>origin</code>\n HTTP header.\n",
        "name": "allow_origin_absence",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"http://localhost:18083, http://127.0.0.1:18083\"",
          "oneliner": true
        },
        "desc": "\nList of allowed origins.<br/>See <code>check_origin_enable</code>.\n",
        "name": "check_origins",
        "raw_default": "http://localhost:18083, http://127.0.0.1:18083",
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:comma_separated_binary()"
        }
      },
      {
        "default": {
          "hocon": "\"x-forwarded-for\"",
          "oneliner": true
        },
        "desc": "\nHTTP header used to pass information about the client IP address.\nRelevant when the EMQX cluster is deployed behind a load-balancer.\n",
        "name": "proxy_address_header",
        "raw_default": [
          120,
          45,
          102,
          111,
          114,
          119,
          97,
          114,
          100,
          101,
          100,
          45,
          102,
          111,
          114
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "\"x-forwarded-port\"",
          "oneliner": true
        },
        "desc": "\nHTTP header used to pass information about the client port.\nRelevant when the EMQX cluster is deployed behind a load-balancer.\n",
        "name": "proxy_port_header",
        "raw_default": [
          120,
          45,
          102,
          111,
          114,
          119,
          97,
          114,
          100,
          101,
          100,
          45,
          112,
          111,
          114,
          116
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "name": "deflate_opts",
        "type": {
          "kind": "struct",
          "name": "broker:deflate_opts"
        }
      }
    ],
    "full_name": "broker:ws_opts",
    "paths": [
      "listeners.ws.$name.websocket",
      "listeners.wss.$name.websocket"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "A `Zone` defines a set of configuration items (such as the maximum number of connections) that can be shared between multiple listeners.\n\n`Listener` can refer to a `Zone` through the configuration item <code>listener.\\<Protocol>.\\<Listener Name>.zone</code>.\n\nThe configs defined in the zones will override the global configs with the same key.\n\nFor example, given the following config:\n```\na {\n    b: 1, c: 1\n}\nzone.my_zone {\n  a {\n    b:2\n  }\n}\n```\n\nThe global config `a` is overridden by the configs `a` inside the zone `my_zone`.\n\nIf there is a listener using the zone `my_zone`, the value of config `a` will be: `{b:2, c: 1}`.\nNote that although the default value of `a.c` is `0`, the global value is used, i.e. configs in the zone have no default values. To override `a.c` one must configure it explicitly in the zone.\n\nAll the global configs that can be overridden in zones are:\n - `stats.*`\n - `mqtt.*`\n - `authorization.*`\n - `flapping_detect.*`\n - `force_shutdown.*`\n - `conn_congestion.*`\n - `force_gc.*`\n\n",
    "fields": [
      {
        "name": "mqtt",
        "type": {
          "kind": "struct",
          "name": "zone:mqtt"
        }
      },
      {
        "name": "stats",
        "type": {
          "kind": "struct",
          "name": "zone:stats"
        }
      },
      {
        "name": "flapping_detect",
        "type": {
          "kind": "struct",
          "name": "zone:flapping_detect"
        }
      },
      {
        "name": "force_shutdown",
        "type": {
          "kind": "struct",
          "name": "zone:force_shutdown"
        }
      },
      {
        "name": "conn_congestion",
        "type": {
          "kind": "struct",
          "name": "zone:conn_congestion"
        }
      },
      {
        "name": "force_gc",
        "type": {
          "kind": "struct",
          "name": "zone:force_gc"
        }
      },
      {
        "name": "overload_protection",
        "type": {
          "kind": "struct",
          "name": "zone:overload_protection"
        }
      }
    ],
    "full_name": "broker:zone",
    "paths": [
      "zones.$name"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Service discovery via DNS SRV records.",
    "fields": [
      {
        "default": {
          "hocon": "\"localhost\"",
          "oneliner": true
        },
        "desc": "The domain name from which to discover peer EMQX nodes' IP addresses.\nApplicable when <code>cluster.discovery_strategy = dns</code>\n",
        "name": "name",
        "raw_default": [
          108,
          111,
          99,
          97,
          108,
          104,
          111,
          115,
          116
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "a",
          "oneliner": true
        },
        "desc": "DNS record type. ",
        "name": "record_type",
        "raw_default": "a",
        "type": {
          "kind": "enum",
          "symbols": [
            "a",
            "srv"
          ]
        }
      }
    ],
    "full_name": "cluster_dns",
    "paths": [
      "cluster.dns"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Service discovery using 'etcd' service.",
    "fields": [
      {
        "desc": "List of endpoint URLs of the etcd cluster",
        "name": "server",
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:comma_separated_list()"
        }
      },
      {
        "default": {
          "hocon": "\"emqxcl\"",
          "oneliner": true
        },
        "desc": "Key prefix used for EMQX service discovery.",
        "name": "prefix",
        "raw_default": [
          101,
          109,
          113,
          120,
          99,
          108
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "\"1m\"",
          "oneliner": true
        },
        "desc": "Expiration time of the etcd key associated with the node.\nIt is refreshed automatically, as long as the node is alive.\n          ",
        "name": "node_ttl",
        "raw_default": [
          49,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "desc": "Options for the TLS connection to the etcd cluster.",
        "name": "ssl",
        "type": {
          "kind": "struct",
          "name": "broker:ssl_client_opts"
        }
      }
    ],
    "full_name": "cluster_etcd",
    "paths": [
      "cluster.etcd"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Service discovery via Kubernetes API server.",
    "fields": [
      {
        "default": {
          "hocon": "\"http://10.110.111.204:8080\"",
          "oneliner": true
        },
        "desc": "Kubernetes API endpoint URL.",
        "name": "apiserver",
        "raw_default": [
          104,
          116,
          116,
          112,
          58,
          47,
          47,
          49,
          48,
          46,
          49,
          49,
          48,
          46,
          49,
          49,
          49,
          46,
          50,
          48,
          52,
          58,
          56,
          48,
          56,
          48
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "\"emqx\"",
          "oneliner": true
        },
        "desc": "EMQX broker service name.",
        "name": "service_name",
        "raw_default": [
          101,
          109,
          113,
          120
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "ip",
          "oneliner": true
        },
        "desc": "Address type used for connecting to the discovered nodes.\nSetting <code>cluster.k8s.address_type</code> to <code>ip</code> will\nmake EMQX to discover IP addresses of peer nodes from Kubernetes API.\n",
        "name": "address_type",
        "raw_default": "ip",
        "type": {
          "kind": "enum",
          "symbols": [
            "ip",
            "dns",
            "hostname"
          ]
        }
      },
      {
        "default": {
          "hocon": "\"default\"",
          "oneliner": true
        },
        "desc": "Kubernetes namespace.",
        "name": "namespace",
        "raw_default": [
          100,
          101,
          102,
          97,
          117,
          108,
          116
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "\"pod.local\"",
          "oneliner": true
        },
        "desc": "Node name suffix.<br/>\nNote: this parameter is only relevant when <code>address_type</code> is <code>dns</code>\nor <code>hostname</code>.",
        "name": "suffix",
        "raw_default": [
          112,
          111,
          100,
          46,
          108,
          111,
          99,
          97,
          108
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      }
    ],
    "full_name": "cluster_k8s",
    "paths": [
      "cluster.k8s"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Service discovery via UDP multicast.",
    "fields": [
      {
        "default": {
          "hocon": "\"239.192.0.1\"",
          "oneliner": true
        },
        "desc": "Multicast IPv4 address.",
        "name": "addr",
        "raw_default": [
          50,
          51,
          57,
          46,
          49,
          57,
          50,
          46,
          48,
          46,
          49
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "[4369,4370]",
          "oneliner": true
        },
        "desc": "List of UDP ports used for service discovery.<br/>\nNote: probe messages are broadcast to all the specified ports.\n          ",
        "name": "ports",
        "raw_default": [
          4369,
          4370
        ],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "integer()"
          },
          "kind": "array"
        }
      },
      {
        "default": {
          "hocon": "\"0.0.0.0\"",
          "oneliner": true
        },
        "desc": "Local IP address the node discovery service needs to bind to.",
        "name": "iface",
        "raw_default": [
          48,
          46,
          48,
          46,
          48,
          46,
          48
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "255",
          "oneliner": true
        },
        "desc": "Time-to-live (TTL) for the outgoing UDP datagrams.",
        "name": "ttl",
        "raw_default": 255,
        "type": {
          "kind": "primitive",
          "name": "0..255"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "If <code>true</code>, loop UDP datagrams back to the local socket.",
        "name": "loop",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"16KB\"",
          "oneliner": true
        },
        "desc": "Size of the kernel-level buffer for outgoing datagrams.",
        "name": "sndbuf",
        "raw_default": [
          49,
          54,
          75,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "\"16KB\"",
          "oneliner": true
        },
        "desc": "Size of the kernel-level buffer for incoming datagrams.",
        "name": "recbuf",
        "raw_default": [
          49,
          54,
          75,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "\"32KB\"",
          "oneliner": true
        },
        "desc": "Size of the user-level buffer.",
        "name": "buffer",
        "raw_default": [
          51,
          50,
          75,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      }
    ],
    "full_name": "cluster_mcast",
    "paths": [
      "cluster.mcast"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Service discovery via static nodes.\nThe new node joins the cluster by connecting to one of the bootstrap nodes.",
    "fields": [
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "List EMQX node names in the static cluster. See <code>node.name</code>.",
        "name": "seeds",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "primitive",
            "name": "atom()"
          },
          "kind": "array"
        }
      }
    ],
    "full_name": "cluster_static",
    "paths": [
      "cluster.static"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Settings that control client authorization.",
    "fields": [
      {
        "default": {
          "hocon": "allow",
          "oneliner": true
        },
        "desc": "\nDefault access control action if the user or client matches no ACL rules,\nor if no such user or client is found by the configurable authorization\nsources such as built_in_database, an HTTP API, or a query against PostgreSQL.\nFind more details in 'authorization.sources' config.\n",
        "name": "no_match",
        "raw_default": "allow",
        "type": {
          "kind": "enum",
          "symbols": [
            "allow",
            "deny"
          ]
        }
      },
      {
        "default": {
          "hocon": "ignore",
          "oneliner": true
        },
        "desc": "The action when the authorization check rejects an operation.",
        "name": "deny_action",
        "raw_default": "ignore",
        "type": {
          "kind": "enum",
          "symbols": [
            "ignore",
            "disconnect"
          ]
        }
      },
      {
        "name": "cache",
        "type": {
          "kind": "struct",
          "name": "broker:cache"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "\nAuthorization data sources.<br/>\nAn array of authorization (ACL) data providers.\nIt is designed as an array, not a hash-map, so the sources can be\nordered to form a chain of access controls.<br/>\n\nWhen authorizing a 'publish' or 'subscribe' action, the configured\nsources are checked in order. When checking an ACL source,\nin case the client (identified by username or client ID) is not found,\nit moves on to the next source. And it stops immediately\nonce an 'allow' or 'deny' decision is returned.<br/>\n\nIf the client is not found in any of the sources,\nthe default action configured in 'authorization.no_match' is applied.<br/>\n\nNOTE:\nThe source elements are identified by their 'type'.\nIt is NOT allowed to configure two or more sources of the same type.\n",
        "name": "sources",
        "raw_default": [],
        "type": {
          "elements": {
            "kind": "union",
            "members": [
              {
                "kind": "struct",
                "name": "authz:file"
              },
              {
                "kind": "struct",
                "name": "authz:http_get"
              },
              {
                "kind": "struct",
                "name": "authz:http_post"
              },
              {
                "kind": "struct",
                "name": "authz:mnesia"
              },
              {
                "kind": "struct",
                "name": "authz:mongo_single"
              },
              {
                "kind": "struct",
                "name": "authz:mongo_rs"
              },
              {
                "kind": "struct",
                "name": "authz:mongo_sharded"
              },
              {
                "kind": "struct",
                "name": "authz:mysql"
              },
              {
                "kind": "struct",
                "name": "authz:postgresql"
              },
              {
                "kind": "struct",
                "name": "authz:redis_single"
              },
              {
                "kind": "struct",
                "name": "authz:redis_sentinel"
              },
              {
                "kind": "struct",
                "name": "authz:redis_cluster"
              }
            ]
          },
          "kind": "array"
        }
      }
    ],
    "full_name": "authorization",
    "paths": [
      "authorization"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "EMQX nodes can form a cluster to scale up the total capacity.<br/>\n      Here holds the configs to instruct how individual nodes can discover each other.",
    "fields": [
      {
        "default": {
          "hocon": "emqxcl",
          "oneliner": true
        },
        "desc": "Human-friendly name of the EMQX cluster.",
        "mapping": "ekka.cluster_name",
        "name": "name",
        "raw_default": "emqxcl",
        "type": {
          "kind": "primitive",
          "name": "atom()"
        }
      },
      {
        "default": {
          "hocon": "manual",
          "oneliner": true
        },
        "desc": "Service discovery method for the cluster nodes.",
        "name": "discovery_strategy",
        "raw_default": "manual",
        "type": {
          "kind": "enum",
          "symbols": [
            "manual",
            "static",
            "mcast",
            "dns",
            "etcd",
            "k8s"
          ]
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "\nList of core nodes that the replicant will connect to.<br/>\nNote: this parameter only takes effect when the <code>backend</code> is set\nto <code>rlog</code> and the <code>role</code> is set to <code>replicant</code>.<br/>\nThis value needs to be defined for manual or static cluster discovery mechanisms.<br/>\nIf an automatic cluster discovery mechanism is being used (such as <code>etcd</code>),\nthere is no need to set this value.\n",
        "mapping": "mria.core_nodes",
        "name": "core_nodes",
        "raw_default": [],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:comma_separated_atoms()"
        }
      },
      {
        "default": {
          "hocon": "\"5m\"",
          "oneliner": true
        },
        "desc": "Remove disconnected nodes from the cluster after this interval.",
        "mapping": "ekka.cluster_autoclean",
        "name": "autoclean",
        "raw_default": [
          53,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "If <code>true</code>, the node will try to heal network partitions automatically.",
        "mapping": "ekka.cluster_autoheal",
        "name": "autoheal",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "inet_tcp",
          "oneliner": true
        },
        "desc": "The Erlang distribution protocol for the cluster.",
        "mapping": "ekka.proto_dist",
        "name": "proto_dist",
        "raw_default": "inet_tcp",
        "type": {
          "kind": "enum",
          "symbols": [
            "inet_tcp",
            "inet6_tcp",
            "inet_tls"
          ]
        }
      },
      {
        "name": "static",
        "type": {
          "kind": "struct",
          "name": "cluster_static"
        }
      },
      {
        "name": "mcast",
        "type": {
          "kind": "struct",
          "name": "cluster_mcast"
        }
      },
      {
        "name": "dns",
        "type": {
          "kind": "struct",
          "name": "cluster_dns"
        }
      },
      {
        "name": "etcd",
        "type": {
          "kind": "struct",
          "name": "cluster_etcd"
        }
      },
      {
        "name": "k8s",
        "type": {
          "kind": "struct",
          "name": "cluster_k8s"
        }
      }
    ],
    "full_name": "cluster",
    "paths": [
      "cluster"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Options for the 'cluster call' feature that allows to execute a callback on all nodes in the cluster.",
    "fields": [
      {
        "default": {
          "hocon": "\"1m\"",
          "oneliner": true
        },
        "desc": "Time interval to retry after a failed call.",
        "name": "retry_interval",
        "raw_default": [
          49,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "100",
          "oneliner": true
        },
        "desc": "Retain the maximum number of completed transactions (for queries).",
        "name": "max_history",
        "raw_default": 100,
        "type": {
          "kind": "primitive",
          "name": "1..500"
        }
      },
      {
        "default": {
          "hocon": "\"5m\"",
          "oneliner": true
        },
        "desc": "Time interval to clear completed but stale transactions.\nEnsure that the number of completed transactions is less than the <code>max_history</code>.",
        "name": "cleanup_interval",
        "raw_default": [
          53,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      }
    ],
    "full_name": "cluster_call",
    "paths": [
      "node.cluster_call"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Log handler that prints log events to the EMQX console.",
    "fields": [
      {
        "default": {
          "hocon": "false",
          "oneliner": true
        },
        "desc": "Enable this log handler.",
        "name": "enable",
        "raw_default": false,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "warning",
          "oneliner": true
        },
        "desc": "\nThe log level for the current log handler.\nDefaults to warning.\n",
        "name": "level",
        "raw_default": "warning",
        "type": {
          "kind": "primitive",
          "name": "emqx_conf_schema:log_level()"
        }
      },
      {
        "default": {
          "hocon": "\"system\"",
          "oneliner": true
        },
        "desc": "\nThe time offset to be used when formatting the timestamp.\nCan be one of:\n  - <code>system</code>: the time offset used by the local system\n  - <code>utc</code>: the UTC time offset\n  - <code>+-[hh]:[mm]</code>: user specified time offset, such as \"-02:00\" or \"+00:00\"\nDefaults to: <code>system</code>.\n",
        "name": "time_offset",
        "raw_default": [
          115,
          121,
          115,
          116,
          101,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "unlimited",
          "oneliner": true
        },
        "desc": "\nSet the maximum length of a single log message. If this length is exceeded, the log message will be truncated.\nNOTE: Restrict char limiter if formatter is JSON , it will get a truncated incomplete JSON data, which is not recommended.\n",
        "name": "chars_limit",
        "raw_default": "unlimited",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "unlimited"
            },
            {
              "kind": "primitive",
              "name": "100..inf"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "text",
          "oneliner": true
        },
        "desc": "Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging.",
        "name": "formatter",
        "raw_default": "text",
        "type": {
          "kind": "enum",
          "symbols": [
            "text",
            "json"
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Print logs in a single line if set to true. Otherwise, log messages may span multiple lines.",
        "name": "single_line",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "100",
          "oneliner": true
        },
        "desc": "As long as the number of buffered log events is lower than this value,\nall log events are handled asynchronously. This means that the client process sending the log event,\nby calling a log function in the Logger API, does not wait for a response from the handler\nbut continues executing immediately after the event is sent.\nIt is not affected by the time it takes the handler to print the event to the log device.\nIf the message queue grows larger than this value,\nthe handler starts handling log events synchronously instead,\nmeaning that the client process sending the event must wait for a response.\nWhen the handler reduces the message queue to a level below the sync_mode_qlen threshold,\nasynchronous operation is resumed.\n",
        "name": "sync_mode_qlen",
        "raw_default": 100,
        "type": {
          "kind": "primitive",
          "name": "non_neg_integer()"
        }
      },
      {
        "default": {
          "hocon": "3000",
          "oneliner": true
        },
        "desc": "When the number of buffered log events is larger than this value, the new log events are dropped.\nWhen drop mode is activated or deactivated, a message is printed in the logs.",
        "name": "drop_mode_qlen",
        "raw_default": 3000,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "default": {
          "hocon": "8000",
          "oneliner": true
        },
        "desc": "If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place.\nTo flush events, the handler discards the buffered log messages without logging.",
        "name": "flush_qlen",
        "raw_default": 8000,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "name": "overload_kill",
        "type": {
          "kind": "struct",
          "name": "log_overload_kill"
        }
      },
      {
        "name": "burst_limit",
        "type": {
          "kind": "struct",
          "name": "log_burst_limit"
        }
      },
      {
        "default": {
          "hocon": "error",
          "oneliner": true
        },
        "desc": "\nType of supervisor reports that are logged. Defaults to <code>error</code>\n  - <code>error</code>: only log errors in the Erlang processes.\n  - <code>progress</code>: log process startup.\n",
        "name": "supervisor_reports",
        "raw_default": "error",
        "type": {
          "kind": "enum",
          "symbols": [
            "error",
            "progress"
          ]
        }
      },
      {
        "default": {
          "hocon": "100",
          "oneliner": true
        },
        "desc": "Maximum depth for Erlang term log formatting and Erlang process message queue inspection.",
        "name": "max_depth",
        "raw_default": 100,
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "unlimited"
            },
            {
              "kind": "primitive",
              "name": "non_neg_integer()"
            }
          ]
        }
      }
    ],
    "full_name": "console_handler",
    "paths": [
      "log.console_handler"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "EMQX logging supports multiple sinks for the log events.\nEach sink is represented by a _log handler_, which can be configured independently.",
    "fields": [
      {
        "name": "console_handler",
        "type": {
          "kind": "struct",
          "name": "console_handler"
        }
      },
      {
        "desc": "File-based log handlers.",
        "name": "file_handlers",
        "type": {
          "kind": "map",
          "name": "name",
          "values": {
            "kind": "struct",
            "name": "log_file_handler"
          }
        }
      }
    ],
    "full_name": "log",
    "paths": [
      "log"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Large bursts of log events produced in a short time can potentially cause problems, such as:\n - Log files grow very large\n - Log files are rotated too quickly, and useful information gets overwritten\n - Overall performance impact on the system\n\nLog burst limit feature can temporarily disable logging to avoid these issues.",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable log burst control feature.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "10000",
          "oneliner": true
        },
        "desc": "Maximum number of log events to handle within a `window_time` interval. After the limit is reached, successive events are dropped until the end of the `window_time`.",
        "name": "max_count",
        "raw_default": 10000,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "default": {
          "hocon": "\"1s\"",
          "oneliner": true
        },
        "desc": "See <code>max_count</code>.",
        "name": "window_time",
        "raw_default": [
          49,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      }
    ],
    "full_name": "log_burst_limit",
    "paths": [
      "log.console_handler.burst_limit",
      "log.file_handlers.$name.burst_limit"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Log handler that prints log events to files.",
    "fields": [
      {
        "desc": "Name the log file.",
        "name": "file",
        "type": {
          "kind": "primitive",
          "name": "emqx_conf_schema:file()"
        }
      },
      {
        "name": "rotation",
        "type": {
          "kind": "struct",
          "name": "log_rotation"
        }
      },
      {
        "default": {
          "hocon": "\"50MB\"",
          "oneliner": true
        },
        "desc": "This parameter controls log file rotation. The value `infinity` means the log file will grow indefinitely, otherwise the log file will be rotated once it reaches `max_size` in bytes.",
        "name": "max_size",
        "raw_default": [
          53,
          48,
          77,
          66
        ],
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "infinity"
            },
            {
              "kind": "primitive",
              "name": "emqx_schema:bytesize()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable this log handler.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "warning",
          "oneliner": true
        },
        "desc": "\nThe log level for the current log handler.\nDefaults to warning.\n",
        "name": "level",
        "raw_default": "warning",
        "type": {
          "kind": "primitive",
          "name": "emqx_conf_schema:log_level()"
        }
      },
      {
        "default": {
          "hocon": "\"system\"",
          "oneliner": true
        },
        "desc": "\nThe time offset to be used when formatting the timestamp.\nCan be one of:\n  - <code>system</code>: the time offset used by the local system\n  - <code>utc</code>: the UTC time offset\n  - <code>+-[hh]:[mm]</code>: user specified time offset, such as \"-02:00\" or \"+00:00\"\nDefaults to: <code>system</code>.\n",
        "name": "time_offset",
        "raw_default": [
          115,
          121,
          115,
          116,
          101,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "unlimited",
          "oneliner": true
        },
        "desc": "\nSet the maximum length of a single log message. If this length is exceeded, the log message will be truncated.\nNOTE: Restrict char limiter if formatter is JSON , it will get a truncated incomplete JSON data, which is not recommended.\n",
        "name": "chars_limit",
        "raw_default": "unlimited",
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "unlimited"
            },
            {
              "kind": "primitive",
              "name": "100..inf"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "text",
          "oneliner": true
        },
        "desc": "Choose log formatter. <code>text</code> for free text, and <code>json</code> for structured logging.",
        "name": "formatter",
        "raw_default": "text",
        "type": {
          "kind": "enum",
          "symbols": [
            "text",
            "json"
          ]
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Print logs in a single line if set to true. Otherwise, log messages may span multiple lines.",
        "name": "single_line",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "100",
          "oneliner": true
        },
        "desc": "As long as the number of buffered log events is lower than this value,\nall log events are handled asynchronously. This means that the client process sending the log event,\nby calling a log function in the Logger API, does not wait for a response from the handler\nbut continues executing immediately after the event is sent.\nIt is not affected by the time it takes the handler to print the event to the log device.\nIf the message queue grows larger than this value,\nthe handler starts handling log events synchronously instead,\nmeaning that the client process sending the event must wait for a response.\nWhen the handler reduces the message queue to a level below the sync_mode_qlen threshold,\nasynchronous operation is resumed.\n",
        "name": "sync_mode_qlen",
        "raw_default": 100,
        "type": {
          "kind": "primitive",
          "name": "non_neg_integer()"
        }
      },
      {
        "default": {
          "hocon": "3000",
          "oneliner": true
        },
        "desc": "When the number of buffered log events is larger than this value, the new log events are dropped.\nWhen drop mode is activated or deactivated, a message is printed in the logs.",
        "name": "drop_mode_qlen",
        "raw_default": 3000,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "default": {
          "hocon": "8000",
          "oneliner": true
        },
        "desc": "If the number of buffered log events grows larger than this threshold, a flush (delete) operation takes place.\nTo flush events, the handler discards the buffered log messages without logging.",
        "name": "flush_qlen",
        "raw_default": 8000,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "name": "overload_kill",
        "type": {
          "kind": "struct",
          "name": "log_overload_kill"
        }
      },
      {
        "name": "burst_limit",
        "type": {
          "kind": "struct",
          "name": "log_burst_limit"
        }
      },
      {
        "default": {
          "hocon": "error",
          "oneliner": true
        },
        "desc": "\nType of supervisor reports that are logged. Defaults to <code>error</code>\n  - <code>error</code>: only log errors in the Erlang processes.\n  - <code>progress</code>: log process startup.\n",
        "name": "supervisor_reports",
        "raw_default": "error",
        "type": {
          "kind": "enum",
          "symbols": [
            "error",
            "progress"
          ]
        }
      },
      {
        "default": {
          "hocon": "100",
          "oneliner": true
        },
        "desc": "Maximum depth for Erlang term log formatting and Erlang process message queue inspection.",
        "name": "max_depth",
        "raw_default": 100,
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "unlimited"
            },
            {
              "kind": "primitive",
              "name": "non_neg_integer()"
            }
          ]
        }
      }
    ],
    "full_name": "log_file_handler",
    "paths": [
      "log.file_handlers.$name"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "\nLog overload kill features an overload protection that activates when the log handlers use too much memory or have too many buffered log messages.<br/>\nWhen the overload is detected, the log handler is terminated and restarted after a cooldown period.\n",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable log handler overload kill feature.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "\"30MB\"",
          "oneliner": true
        },
        "desc": "Maximum memory size that the log handler process is allowed to use.",
        "name": "mem_size",
        "raw_default": [
          51,
          48,
          77,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "20000",
          "oneliner": true
        },
        "desc": "Maximum allowed queue length.",
        "name": "qlen",
        "raw_default": 20000,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "default": {
          "hocon": "\"5s\"",
          "oneliner": true
        },
        "desc": "If the handler is terminated, it restarts automatically after a delay specified in milliseconds. The value `infinity` prevents restarts.",
        "name": "restart_after",
        "raw_default": [
          53,
          115
        ],
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "primitive",
              "name": "emqx_schema:duration_ms()"
            },
            {
              "kind": "singleton",
              "name": "infinity"
            }
          ]
        }
      }
    ],
    "full_name": "log_overload_kill",
    "paths": [
      "log.console_handler.overload_kill",
      "log.file_handlers.$name.overload_kill"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "\nBy default, the logs are stored in `./log` directory (for installation from zip file) or in `/var/log/emqx` (for binary installation).<br/>\nThis section of the configuration controls the number of files kept for each log handler.\n",
    "fields": [
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable log rotation feature.",
        "name": "enable",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      },
      {
        "default": {
          "hocon": "10",
          "oneliner": true
        },
        "desc": "Maximum number of log files.",
        "name": "count",
        "raw_default": 10,
        "type": {
          "kind": "primitive",
          "name": "1..2048"
        }
      }
    ],
    "full_name": "log_rotation",
    "paths": [
      "log.file_handlers.$name.rotation"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "Node name, cookie, config & data directories and the Erlang virtual machine (BEAM) boot parameters.",
    "fields": [
      {
        "default": {
          "hocon": "\"emqx@127.0.0.1\"",
          "oneliner": true
        },
        "desc": "Unique name of the EMQX node. It must follow <code>%name%@FQDN</code> or\n<code>%name%@IPv4</code> format.\n          ",
        "name": "name",
        "raw_default": [
          101,
          109,
          113,
          120,
          64,
          49,
          50,
          55,
          46,
          48,
          46,
          48,
          46,
          49
        ],
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "desc": "Secret cookie is a random string that should be the same on all nodes in\nthe given EMQX cluster, but unique per EMQX cluster. It is used to prevent EMQX nodes that\nbelong to different clusters from accidentally connecting to each other.",
        "mapping": "vm_args.-setcookie",
        "name": "cookie",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "default": {
          "hocon": "2097152",
          "oneliner": true
        },
        "desc": "Maximum number of simultaneously existing processes for this Erlang system.\nThe actual maximum chosen may be much larger than the Number passed.\nFor more information, see: https://www.erlang.org/doc/man/erl.html\n          ",
        "mapping": "vm_args.+P",
        "name": "process_limit",
        "raw_default": 2097152,
        "type": {
          "kind": "primitive",
          "name": "1024..134217727"
        }
      },
      {
        "default": {
          "hocon": "1048576",
          "oneliner": true
        },
        "desc": "Maximum number of simultaneously existing ports for this Erlang system.\nThe actual maximum chosen may be much larger than the Number passed.\nFor more information, see: https://www.erlang.org/doc/man/erl.html\n          ",
        "mapping": "vm_args.+Q",
        "name": "max_ports",
        "raw_default": 1048576,
        "type": {
          "kind": "primitive",
          "name": "1024..134217727"
        }
      },
      {
        "default": {
          "hocon": "8192",
          "oneliner": true
        },
        "desc": "Erlang's distribution buffer busy limit in kilobytes.",
        "mapping": "vm_args.+zdbbl",
        "name": "dist_buffer_size",
        "raw_default": 8192,
        "type": {
          "kind": "primitive",
          "name": "1..2097151"
        }
      },
      {
        "default": {
          "hocon": "262144",
          "oneliner": true
        },
        "desc": "Max number of ETS tables",
        "mapping": "vm_args.+e",
        "name": "max_ets_tables",
        "raw_default": 262144,
        "type": {
          "kind": "primitive",
          "name": "pos_integer()"
        }
      },
      {
        "desc": "\nPath to the persistent data directory.<br/>\nPossible auto-created subdirectories are:<br/>\n- `mnesia/<node_name>`: EMQX's built-in database directory.<br/>\nFor example, `mnesia/emqx@127.0.0.1`.<br/>\nThere should be only one such subdirectory.<br/>\nMeaning, in case the node is to be renamed (to e.g. `emqx@10.0.1.1`),<br/>\nthe old dir should be deleted first.<br/>\n- `configs`: Generated configs at boot time, and cluster/local override configs.<br/>\n- `patches`: Hot-patch beam files are to be placed here.<br/>\n- `trace`: Trace log files.<br/>\n\n**NOTE**: One data dir cannot be shared by two or more EMQX nodes.\n",
        "mapping": "emqx.data_dir",
        "name": "data_dir",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "desc": "List of configuration files that are read during startup. The order is\nsignificant: later configuration files override the previous ones.\n          ",
        "mapping": "emqx.config_files",
        "name": "config_files",
        "type": {
          "kind": "primitive",
          "name": "[string()]"
        }
      },
      {
        "default": {
          "hocon": "\"15m\"",
          "oneliner": true
        },
        "desc": "Periodic garbage collection interval. Set to <code>disabled</code> to have it disabled.",
        "mapping": "emqx_machine.global_gc_interval",
        "name": "global_gc_interval",
        "raw_default": [
          49,
          53,
          109
        ],
        "type": {
          "kind": "union",
          "members": [
            {
              "kind": "singleton",
              "name": "disabled"
            },
            {
              "kind": "primitive",
              "name": "emqx_schema:duration()"
            }
          ]
        }
      },
      {
        "default": {
          "hocon": "\"log/erl_crash.dump\"",
          "oneliner": true
        },
        "desc": "Location of the crash dump file.",
        "mapping": "vm_args.-env ERL_CRASH_DUMP",
        "name": "crash_dump_file",
        "raw_default": [
          108,
          111,
          103,
          47,
          101,
          114,
          108,
          95,
          99,
          114,
          97,
          115,
          104,
          46,
          100,
          117,
          109,
          112
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_conf_schema:file()"
        }
      },
      {
        "default": {
          "hocon": "\"30s\"",
          "oneliner": true
        },
        "desc": "The number of seconds that the broker is allowed to spend writing a crash dump.",
        "mapping": "vm_args.-env ERL_CRASH_DUMP_SECONDS",
        "name": "crash_dump_seconds",
        "raw_default": [
          51,
          48,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration_s()"
        }
      },
      {
        "default": {
          "hocon": "\"100MB\"",
          "oneliner": true
        },
        "desc": "The maximum size of a crash dump file in bytes.",
        "mapping": "vm_args.-env ERL_CRASH_DUMP_BYTES",
        "name": "crash_dump_bytes",
        "raw_default": [
          49,
          48,
          48,
          77,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "\"2m\"",
          "oneliner": true
        },
        "desc": "This is the approximate time an EMQX node may be unresponsive until it is considered down and thereby disconnected.",
        "mapping": "vm_args.-kernel net_ticktime",
        "name": "dist_net_ticktime",
        "raw_default": [
          50,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration_s()"
        }
      },
      {
        "default": {
          "hocon": "23",
          "oneliner": true
        },
        "desc": "Maximum depth of the call stack printed in error messages and\n<code>process_info</code>.\n          ",
        "mapping": "emqx_machine.backtrace_depth",
        "name": "backtrace_depth",
        "raw_default": 23,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "[]",
          "oneliner": true
        },
        "desc": "List of Erlang applications that shall be rebooted when the EMQX broker joins the cluster.\n          ",
        "mapping": "emqx_machine.applications",
        "name": "applications",
        "raw_default": [],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:comma_separated_atoms()"
        }
      },
      {
        "desc": "Deprecated since 5.0.8.",
        "name": "etc_dir",
        "type": {
          "kind": "primitive",
          "name": "string()"
        }
      },
      {
        "name": "cluster_call",
        "type": {
          "kind": "struct",
          "name": "cluster_call"
        }
      },
      {
        "default": {
          "hocon": "rlog",
          "oneliner": true
        },
        "desc": "\nSelect the backend for the embedded database.<br/>\n<code>rlog</code> is the default backend,\nthat is suitable for very large clusters.<br/>\n<code>mnesia</code> is a backend that offers decent performance in small clusters.\n",
        "mapping": "mria.db_backend",
        "name": "db_backend",
        "raw_default": "rlog",
        "type": {
          "kind": "enum",
          "symbols": [
            "mnesia",
            "rlog"
          ]
        }
      },
      {
        "default": {
          "hocon": "core",
          "oneliner": true
        },
        "desc": "\nSelect a node role.<br/>\n<code>core</code> nodes provide durability of the data, and take care of writes.\nIt is recommended to place core nodes in different racks or different availability zones.<br/>\n<code>replicant</code> nodes are ephemeral worker nodes. Removing them from the cluster\ndoesn't affect database redundancy<br/>\nIt is recommended to have more replicant nodes than core nodes.<br/>\nNote: this parameter only takes effect when the <code>backend</code> is set\nto <code>rlog</code>.\n",
        "mapping": "mria.node_role",
        "name": "db_role",
        "raw_default": "core",
        "type": {
          "kind": "enum",
          "symbols": [
            "core",
            "replicant"
          ]
        }
      },
      {
        "default": {
          "hocon": "gen_rpc",
          "oneliner": true
        },
        "desc": "Protocol used for pushing transaction logs to the replicant nodes.",
        "mapping": "mria.rlog_rpc_module",
        "name": "rpc_module",
        "raw_default": "gen_rpc",
        "type": {
          "kind": "enum",
          "symbols": [
            "gen_rpc",
            "rpc"
          ]
        }
      },
      {
        "default": {
          "hocon": "async",
          "oneliner": true
        },
        "desc": "\nIn sync mode the core node waits for an ack from the replicant nodes before sending the next\ntransaction log entry.\n",
        "mapping": "mria.tlog_push_mode",
        "name": "tlog_push_mode",
        "raw_default": "async",
        "type": {
          "kind": "enum",
          "symbols": [
            "sync",
            "async"
          ]
        }
      }
    ],
    "full_name": "node",
    "paths": [
      "node"
    ],
    "tags": [
      "EMQX"
    ]
  },
  {
    "desc": "EMQX uses a library called <code>gen_rpc</code> for inter-broker communication.<br/>\nMost of the time the default config should work,\nbut in case you need to do performance fine-tuning or experiment a bit,\nthis is where to look.",
    "fields": [
      {
        "default": {
          "hocon": "async",
          "oneliner": true
        },
        "desc": "In <code>sync</code> mode the sending side waits for the ack from the receiving side.",
        "name": "mode",
        "raw_default": "async",
        "type": {
          "kind": "enum",
          "symbols": [
            "sync",
            "async"
          ]
        }
      },
      {
        "default": {
          "hocon": "tcp",
          "oneliner": true
        },
        "desc": "Transport protocol used for inter-broker communication",
        "mapping": "gen_rpc.driver",
        "name": "driver",
        "raw_default": "tcp",
        "type": {
          "kind": "enum",
          "symbols": [
            "tcp",
            "ssl"
          ]
        }
      },
      {
        "default": {
          "hocon": "256",
          "oneliner": true
        },
        "desc": "The maximum number of batch messages sent in asynchronous mode.\n      Note that this configuration does not work in synchronous mode.\n      ",
        "mapping": "gen_rpc.max_batch_size",
        "name": "async_batch_size",
        "raw_default": 256,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "stateless",
          "oneliner": true
        },
        "desc": "<code>manual</code>: discover ports by <code>tcp_server_port</code>.<br/>\n<code>stateless</code>: discover ports in a stateless manner, using the following algorithm.\nIf node name is <code>emqxN@127.0.0.1</code>, where the N is an integer,\nthen the listening port will be 5370 + N.",
        "mapping": "gen_rpc.port_discovery",
        "name": "port_discovery",
        "raw_default": "stateless",
        "type": {
          "kind": "enum",
          "symbols": [
            "manual",
            "stateless"
          ]
        }
      },
      {
        "default": {
          "hocon": "5369",
          "oneliner": true
        },
        "desc": "Listening port used by RPC local service.<br/>\nNote that this config only takes effect when rpc.port_discovery is set to manual.",
        "mapping": "gen_rpc.tcp_server_port",
        "name": "tcp_server_port",
        "raw_default": 5369,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "5369",
          "oneliner": true
        },
        "desc": "Listening port used by RPC local service.<br/>\nNote that this config only takes effect when rpc.port_discovery is set to manual\nand <code>driver</code> is set to <code>ssl</code>.",
        "mapping": "gen_rpc.ssl_server_port",
        "name": "ssl_server_port",
        "raw_default": 5369,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "10",
          "oneliner": true
        },
        "desc": "Set the maximum number of RPC communication channels initiated by this node to each remote node.",
        "name": "tcp_client_num",
        "raw_default": 10,
        "type": {
          "kind": "primitive",
          "name": "1..256"
        }
      },
      {
        "default": {
          "hocon": "\"5s\"",
          "oneliner": true
        },
        "desc": "Timeout for establishing an RPC connection.",
        "mapping": "gen_rpc.connect_timeout",
        "name": "connect_timeout",
        "raw_default": [
          53,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "desc": "Path to TLS certificate file used to validate identity of the cluster nodes.\nNote that this config only takes effect when <code>rpc.driver</code> is set to <code>ssl</code>.\n      ",
        "mapping": "gen_rpc.certfile",
        "name": "certfile",
        "type": {
          "kind": "primitive",
          "name": "emqx_conf_schema:file()"
        }
      },
      {
        "desc": "Path to the private key file for the <code>rpc.certfile</code>.<br/>\nNote: contents of this file are secret, so it's necessary to set permissions to 600.",
        "mapping": "gen_rpc.keyfile",
        "name": "keyfile",
        "type": {
          "kind": "primitive",
          "name": "emqx_conf_schema:file()"
        }
      },
      {
        "desc": "Path to certification authority TLS certificate file used to validate <code>rpc.certfile</code>.<br/>\nNote: certificates of all nodes in the cluster must be signed by the same CA.",
        "mapping": "gen_rpc.cacertfile",
        "name": "cacertfile",
        "type": {
          "kind": "primitive",
          "name": "emqx_conf_schema:file()"
        }
      },
      {
        "default": {
          "hocon": "\"5s\"",
          "oneliner": true
        },
        "desc": "Timeout for sending the RPC request.",
        "mapping": "gen_rpc.send_timeout",
        "name": "send_timeout",
        "raw_default": [
          53,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"5s\"",
          "oneliner": true
        },
        "desc": "Timeout for the remote node authentication.",
        "mapping": "gen_rpc.authentication_timeout",
        "name": "authentication_timeout",
        "raw_default": [
          53,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"15s\"",
          "oneliner": true
        },
        "desc": "Timeout for the reply to a synchronous RPC.",
        "mapping": "gen_rpc.call_receive_timeout",
        "name": "call_receive_timeout",
        "raw_default": [
          49,
          53,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration()"
        }
      },
      {
        "default": {
          "hocon": "\"15m\"",
          "oneliner": true
        },
        "desc": "How long the connections between the brokers should remain open after the last message is sent.",
        "mapping": "gen_rpc.socket_keepalive_idle",
        "name": "socket_keepalive_idle",
        "raw_default": [
          49,
          53,
          109
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration_s()"
        }
      },
      {
        "default": {
          "hocon": "\"75s\"",
          "oneliner": true
        },
        "desc": "The interval between keepalive messages.",
        "mapping": "gen_rpc.socket_keepalive_interval",
        "name": "socket_keepalive_interval",
        "raw_default": [
          55,
          53,
          115
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:duration_s()"
        }
      },
      {
        "default": {
          "hocon": "9",
          "oneliner": true
        },
        "desc": "How many times the keepalive probe message can fail to receive a reply\nuntil the RPC connection is considered lost.",
        "mapping": "gen_rpc.socket_keepalive_count",
        "name": "socket_keepalive_count",
        "raw_default": 9,
        "type": {
          "kind": "primitive",
          "name": "integer()"
        }
      },
      {
        "default": {
          "hocon": "\"1MB\"",
          "oneliner": true
        },
        "desc": "TCP tuning parameters. TCP sending buffer size.",
        "mapping": "gen_rpc.socket_sndbuf",
        "name": "socket_sndbuf",
        "raw_default": [
          49,
          77,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "\"1MB\"",
          "oneliner": true
        },
        "desc": "TCP tuning parameters. TCP receiving buffer size.",
        "mapping": "gen_rpc.socket_recbuf",
        "name": "socket_recbuf",
        "raw_default": [
          49,
          77,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "\"1MB\"",
          "oneliner": true
        },
        "desc": "TCP tuning parameters. Socket buffer size in user mode.",
        "mapping": "gen_rpc.socket_buffer",
        "name": "socket_buffer",
        "raw_default": [
          49,
          77,
          66
        ],
        "type": {
          "kind": "primitive",
          "name": "emqx_schema:bytesize()"
        }
      },
      {
        "default": {
          "hocon": "true",
          "oneliner": true
        },
        "desc": "Enable compatibility with old RPC authentication.",
        "mapping": "gen_rpc.insecure_auth_fallback_allowed",
        "name": "insecure_fallback",
        "raw_default": true,
        "type": {
          "kind": "primitive",
          "name": "boolean()"
        }
      }
    ],
    "full_name": "rpc",
    "paths": [
      "rpc"
    ],
    "tags": [
      "EMQX"
    ]
  }
]